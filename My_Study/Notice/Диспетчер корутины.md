```kotlin
//Контекст корутины включает себя такой элемент как диспетчер корутины. Диспетчер корутины определяет какой поток или какие потоки будут использоваться для выполнения корутины.

//Все построители корутины, в частности, функции launch и async в качестве необязательного параметра принимают объект типа CoroutineContext, который может использоваться для определения диспетчера создаваемой корутины.

//Когда функция launch вызывается без параметров, она перенимает контекст, в котором она создается и запускается. Например, используем метод Thread.currentThread(), который предоставляет JDK, чтобы получить данные потока корутины:

suspend fun main() = coroutineScope<Unit>{  
   val job = launch(Dispatchers.Default,CoroutineStart.LAZY){  
       println("${Thread.currentThread().name}")  
   }  
    job.start()  
    launch{  
        println("Эта корутина работает в потоке ${Thread.currentThread().name}")  
    }  
    println("Main работает в потоке ${Thread.currentThread().name}")  
}

/*
DefaultDispatcher-worker-1
Main работает в потоке main
Эта корутина работает в потоке DefaultDispatcher-worker-1
*/

//Поскольку контекст корутин в функции `main` создается в данном случае с помощью функции coroutineScope, которая устанавливает для создаваемых корутин по умолчанию диспетчер типа Dispatcher.Default. И, корутина, определенная в примере выше перенимает этот контекст вместе с данным типом диспетчера.

//Что это значит? Рассмотрим доступные типы диспетчеров:

//- Dispatchers.Default: применяется по умолчанию, если тип диспетчера не указан явным образом. Этот тип использует общий пул разделяемых фоновых потоков и подходит для вычислений, которые не работают с операциями ввода-вывода (операциями с файлами, базами данных, сетью) и которые требуют интенсивного потребления ресурсов центрального процессора.
    
//- Dispatchers.IO: использует общий пул потоков, создаваемых по мере необходимости, и предназначен для выполнения операций ввода-вывода (например, операции с файлами или сетевыми запросами).
    
//- Dispatchers.Main: применяется в графических приложениях, например, в приложениях Android или JavaFX.
    
//- Dispatchers.Unconfined: корутина не закреплена четко за определенным потоком или пулом потоков. Она запускается в текущем потоке до первой приостановки. После возобновления работы корутина продолжает работу в одном из потоков, который сторого не фиксирован. Разработчики языка Kotlin в обычной ситуации не рекомендуют использовать данный тип.
    
//- newSingleThreadContext и newFixedThreadPoolContext: позволяют вручную задать поток/пул для выполнения корутины

//Dispatchers.Unconfined

//Тип Dispatchers.Unconfined запускает корутину в текущем вызывающем потоке до первой приостановки. После возобновления корутина продолжает работу в одном из потоков, который строго не фиксирован. Подобный тип подходит для корутин, которым не требуется интенсивно потреблять время CPU или работать с общими данными, наподобие объектов пользовательского интерфейса.

//newSingleThreadContext

//newSingleThreadContext вручную запускает поток с указанным именем:
import kotlinx.coroutines.*

suspend` fun main() = coroutineScope{`

    `launch(newSingleThreadContext("Custom Thread")) {

        println("Поток корутины: ${Thread.currentThread().name}")

    }

    println("Поток функции main: ${Thread.currentThread().name}")

}

//В данном случае для выполнения корутины будет запускаться поток с именем "Custom Thread". Консольный вывод:

//Поток функции main: main
//Поток корутины: Custom Thread

//В то же время выделенный поток является довольно затратным ресурсом. И в реальном приложении подобый поток следует либо освобождать с помощью функции close(), если он больше не нужен, либо хранить в глобальной переменной и использовать его повторно для подобных задач на протяжении работы приложения.
```