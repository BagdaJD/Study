```kotlin
//Каналы позволяют передавать потоки данных. В Kotlin каналы представлены интерфейсом Channel, у которого следует выделить два основных метода:

// abstract suspend fun send(element: E): Unit
    
  //  Отправляет объект element в канал
    
//abstract suspend fun receive(): E
    
  //  Получает данные из канала

//Определим простейший канал, через который будем передавать числа типа Int:
suspend fun main() = coroutineScope<Unit>{  
    val channel = Channel<Int>()  
    launch{  
        for(n in 0..5){  
            channel.send(n)  
            delay(500L)  
        }    }  
    repeat(5){  
        val num = channel.receive()  
        println(num)  
    }  
}
//Вывод
//0
//1
//2
//3
//4
//Притом выполняется параллельно

//Основная функциональность каналов сосредочена в пакете kotlinx.coroutines.channels, соответственно импортируем из него тип Channel

//Поскольку через канал будут передаваться значения типа Int, то соответственно объект Channel типизирован типом Int.

//В метод send() собственно передается то значение, которое мы хотим отправить через канал. Особенностью этого метода является то, что мы можем его запустить только в корутине.
//Для получения данных из канала с помощью функции repeat() определяем функцию, которая будет выполнятся 5 раз - так как мы передаем в канал пять чисел

//Метод receive() возвращает извлекаемый из канала объект.

//Закрытие канала
//Чтобы указать, что в канале больше нет данных, его можно закрыть с помощью метода close(). Если для получения данных из канала применяется цикл for, то, получив сигнал о закрытии канала, данный цикл получит все ранее посланные объекты до закрытия и завершит выполнение
suspend fun main() = coroutineScope<Unit>{  
    val channel = Channel<Int>()  
    launch{  
        for(n in 0..5){  
            channel.send(n)  
            delay(500L)  
        }        channel.close()  
    }  
    for(num in channel){  
        println(num)  
    }}
//Лучше поток закрывать и пользоваться такой реализацией, т.к после закрытия потока и мы выведем числа и прекратим работу, а если напишем repeat(), то программа продолжит свою работу и дальше, продолжая тратить ресурсы
```
### Паттерн producer-consumer
```kotlin
//Вкратце - построитель корутины для запуска потока
//с передаваемыми значениями(упрощенная версия для передачи данных)

//Рассмотренный выше пример по сути является распростаненным способом передачи данных от одной корутины к другой. И чтобы упростить написание подобного кода, Kotlin предоставляет ряд дополнительных функций. Так, функция produce() представляет построитель корутины, который создает корутину, в которой передаются данные в канал. Например, с помощью функции `produce()` мы можем определить новую функцию-корутину, которая будет отправлять определенные данные:
suspend fun CoroutineScope.getUsers() : ReceiveChannel<String> = produce{  
    val users = listOf("String", "Int", "Boolean")  
    for(user in users){  
        send(user)  
        delay(400L)  
    }
}  
  
suspend fun main() = coroutineScope<Unit>{  
    val users = getUsers()  
    users.consumeEach {user -> println(user)}  
}

/*
String
Int
Boolean
*/
// Здесь определяется функция getUsers(). Причем она определяется как функция интерфейса CoroutineScope. Функция должна возвращать объект ReceiveChannel, типизированный типом передаваемых данных (в данном случае передаем значения типа String).

//Функция getUsers() представляет корутину, создаваемую построителем корутин produce. В корутине опять же проходим по списку строк и с помощью функции send передаем в канал данные.

//Для потребления данных из канала может применяться метод consumeEach() объекта ReceiveChannel, который по сути заменяет цикл for. Он принимает функцию, в которую в качестве параметра передается получаемый из канала объект 
```