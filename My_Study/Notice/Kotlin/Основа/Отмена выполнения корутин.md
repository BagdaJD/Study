```kotlin
//При работе приложения может сложиться необходимость отменить выполнение корутины. Например, в мобильном приложении запущена корутина для загрузки данных с некоторого интернет-ресуса, но пользователь решил перейти к другой странице приложения, и ему больше не нужны эти данные. В этом случае чтобы зря не тратить ресурсу системы, мы можем предусмотреть отмену выполнения корутины.

//Для отмены выполнения корутины у объекта Job может применяться метод cancel():

suspend fun main() = coroutineScope{  
    val downloader: Job = launch{  
        for(i in 0..5){  
            println("Downloading $i")  
            delay(500L)  
        }    }  
    delay(700L)  
    println("Start")  
    downloader.cancel()  
    downloader.join()  
    println("Finish")  
}
//В данном случае определена корутина, которая имитирует загрузку файлов. В цикле пробегаемся от 1 до 5 и условно загружаем пять файлов.

//Далее вызов метода downloader.cancel() сигнализирует корутине, что надо прервать выполнение. Затем с помощью метода join() ожидаем завершения корутина, которая прервана.

/*
Downloading 0
Downloading 1
Start
Finish
*/

//Также вместо двух методов cancel() и join() можно использовать один сборный метод cancelAndJoin()

suspend fun main() = coroutineScope{  
    val downloader: Job = launch{  
        for(i in 0..5){  
            println("Downloading $i")  
            delay(500L)  
        }    }  
    delay(700L)  
    println("Start")  
    downloader.cancelAndJoin()  
    println("Finish")  
}
```
### Обработка исключения CancellationException
```kotlin
//Все suspend-функции в пакете kotlinx.coroutines являются прерываемыми (cancellable). Это значит, что они проверяют, прервана ли корутина. И если ее выполнение прервано, они генерируют исключение типа CancellationException. И в самой корутине мы можем перехватить это исключение, чтобы обработать отмену корутины.

suspend fun main() = coroutineScope{  
    val downloader: Job = launch{  
        try{  
            for(i in 0..5){  
                println("Downloading $i")  
                delay(500L)  
            }        }catch(e: CancellationException){  
            println("Error downloading")  
        }finally {  
            println("Finishing downloading")  
        }  
    }  
    delay(700L)  
    println("Start")  
    downloader.cancelAndJoin()  
    println("Finish")  
}
//Здесь код выполнения корутины обернут в конструкцию try. Если корутина будет прервана извне, то с помощью блока catch и перехвата исключения CancellationException мы сможем обработать отмену корутины.

//И если нам надо выполнить некоторые завершающие действия, например, освободить используемые в корутине ресурсы - закрыть файлы, различные подключения к внешним ресурсам, то это можно сделать в блоке finally. Но в данном случае в этом блоке просто выводим диагностическое сообщение.

//В итоге при вызове метода downloader.cancel() производейт отмена корутины. Будет сгенерировано исключение, и в корутине в блоке catch мы сможем ее обработать. В итоге получим следующий консольный вывод:
/*
Downloading 0
Downloading 1
Start
Error downloading
Finishing downloading
Finish
*/
```
### Отмена async-корутины
```kotlin
//Подобным образом можно отменять выполнение и корутин, создаваемых с помощью функции async(). В этом случае обычно вызов метода await() помещается в блок try:

suspend fun main() = coroutineScope{  
    val msg = async{getMessage()}  
  
    msg.cancelAndJoin()  
    try{  
        println(msg.await())  
    }catch (e: CancellationException){  
        println("Error")  
    }finally {  
        println("Finish")  
    }
}
//Error
//Finish

```