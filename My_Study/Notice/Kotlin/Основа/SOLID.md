**S-Single Responsibiloty**(Принцип ответственности)
Принцип гласит о том, что не должно быть год-объектов: у каждого класса должна быть своя какая-либо ответственность и функционал

**D-Dependency Inversion**(Инверсия зависимостей)
Вместо реализаций использовать абстракции, не допуская того, чтобы **domain-слой** зависел от чего либо
(Инверсия зависимостей так и называется, чтобы изменить зависимость в виде реализации, на абстракцию этой реализации)

 **I-Interface Segretation**(Принцип разделения интерфейсов)
 Суть принципа заключается в том, чтобы при создании интерфейса оставлять в нем только самые нужные методы, чтобы в дальнейшем при использовании этого интерфейса не приходилось впустую переопределять ненужные методы. Лучше всего дробить интерфейсы(но тоже не увлекаться этим)

**L-Liskov Substitution**(Принцип подстановки Барбары Лисков)
Принцип говорит о том, что если мы в системе заменим одного наследника одного другим наследником этого же класса, то в этом случае поведение программы не должно измениться. Если после измены наследника программа перестает работать, то этот класс не является наследником того класса, от которого наследуется. Нужно правильно строить систему наследования

**O-Open Closed Principle**(Принцип открытости/закрытости)
*"Программные сущности(классы, функции) должны быть открыты для расширения и закрыты для изменения"*

Про закрытость: имеется в виду, что если вы написали класс и т.д, который работает на 100%, не имел возможности изменяться другими программистами, т.к иначе это могло бы привести к ошибкам(т.к от вашего класса зависели и другие компоненты) и пришлось бы заново его тестировать и т.д
Но иногда приходится самому дополнять свои классы, тогда это нужно делать так, чтобы новые компоненты программы затрагивали старые по минимуму и вносили в их работу минимум изменений 


Лучше создать класс, которые наследуется от нужного класса, и расширить новосозданный класс необходимым функционалом.

Про открытость: как я написал выше, каждый класс должен давать возможность наследоваться от себя для расширения собственного функционала, не изменяя себя.