```kotlin
/*
В языке Kotlin поддержка асинхронности и параллельных вычислений воплощена в виде корутин (coroutine). По сути корутина представляет блок кода, который может выполняться параллельно с остальным кодом. А базовая функциональность, связанная с корутинами, сосредоточена в библиотеке kotlinx.coroutines.
*/
//Добавление
//Меню -> Project Structure -> Libraries -> + -> From Maven -> kotlinx-coroutines-core-jvm:(version)
//И выбираем все подпункты Transitive dependencies, Sources, Javadocs, Annotations

import kotlinx.coroutines.*  
  
suspend fun main(){  
    for(i in 0..5){  
        println(i)  
        delay(400L)  
    }    
    println("Hello Coroutines")  
}

//suspend - означает, что функция может приостанавливать и возобновлять свою работу 
//без suspend будет ошибка
//delay() - функция которая вызывает, приостановку на указанное кол-во времени(в данном случае, на 400 мл, параметр она принимает тиа Long)
//Вывод:
0
1
2
3
4
5
Hello Coroutines


//Определение корутины
suspend fun main() = coroutineScope{  
    launch {  
        for(i in 0..5){  
            println(i)  
        }    
    }  
    println("Hello")  
}
//Для начала нужно определить контекст для выполнения корутины, корутина может выполняться только в нем(coroutine scope)
//coroutineScope() - создает контекст корутины
//coroutineScope() применяется только с модификатором suspend
//Сама корутина определяется и запускается с помощью построителя корутин - функции launch

//Вывод
Hello
0
1
2
3
4
5

//Вынесение функционала корутины в отдельную функцию
suspend fun doWork() {  
    for(i in 0..5){  
        println("I working a $i hours")  
        delay(400L)  
    }}  
  
suspend fun main() = coroutineScope{  
    launch {doWork()}  
    println("Hello")  
}
//если убрать println("Hello") в основной прогрпмме, то код не заработает, т.к корутина выполняется параллельно основной программе
//чтобы исправить это можем написать следующее
suspend fun main() = coroutineScope{  
    launch {doWork()}  
    Unit  
}
//или

suspend fun main() = coroutineScope<Unit>{  
    launch {doWork()}   
}

//Корутины и потоки

/*
В ряде языков программирования есть такие структуры, которые позволяют использовать потоки. Однако между корутинами и потоками нет прямого соответствия. Корутина не привязана к конкретному потоку. Она может быть приостановить выполнение в одном потоке, а возобновить выполнение в другом.

Когда корутина приостанавливает свое выполнение, например, как в случае выше при вызове задержки с помощью функции `delay()`, эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти. А освобожденный поток может быть зайдествован для других задач. А когда завершается запущенная задача (например, выполнение функции `delay()`), корутина возобновляет свою работу в одном из свободных потоков.
*/
```
