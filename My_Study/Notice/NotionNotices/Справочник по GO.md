# Справочник по GO

- ***Введение***
    
    ```go
    package main - название пакета(этого кода)
    //с помощью оператора package указывается, к какому пакету будет принадлежать файл
    //Причем пакет должен называться именно main, так как именно данный пакет определяет исполняемый файл
    
    import "fmt" - в этом пакете хранятся функции ответсвенные за работу с текстом(Println)
    func - это объявление функции
    //Далее идет функция main. Это главная функция любой программы на Go. По сути все,
    // что выполняется в программе, выполняется именно функции main.
    
    ---------------------------------------------------------------------------------------
    package main
    
    import "fmt" - подключаем пакет fmt
    
    func main() {
    	fmt.Println("Hello Go!")
    }
    
    															Компиляция
    		1.Нужно перейти в папку с go файлом
    		2.go run hello.go - написать go run перед названием файла
    
    //go - это компилятор. Поскольку при установке путь к компилятору автоматически
    //прописывается в переменную PATH в переменных окружения, то нам не надо указывать 
    //полный путь C:\Go\bin\go.exe, а достаточно написать просто имя приложения go.
    
    //Далее идет параметр run, который говорит, что мы просто 
    //хотим выполнить программу
    
    go build hello.go - делает из кода go файл exe
    
    // - комменарий на одну строку
    /**/ - комментарий на определенный блок кода
    
    											----Доп. инфа----
    
    Причем главный пакет программы должен называться "main". 
    Так как именно данный пакет определяет, что будет 
    создаваться исполняемый файл приложения, который после
    компиляции можно будет запускать на выполнение.
    
    После подключения других пакетов располагаются объявления 
    типов, переменных, функций, констант.
    
    При этом входной точкой в приложения является функция с именем main. 
    Она обязательно должна быть определена в программе. Все, что выполняется
    в программе, выполняется именно в функции main.
    
    Базовым элементом программы являются инструкции. Например, 
    вызов функции fmt.Println("Hello Go!") представляет отдельную 
    инструкцию. Каждая инструкция выполняет определенное действие и 
    размещается на новой строке
    
    -------------------------------------------------------------------------
    
    Можно размещать несколько инструкций и на одной строке, но тогда их 
    надо отделять точкой запятой:
    
    package main
    import "fmt"
     
    func main() {
        fmt.Println("Hello Go!");fmt.Println("Hello Golang!");fmt.Println("Hello Go!")
    }
    ```
    
- ***Основы (Переменые)***
    
    ```go
    									
    
    	Переменные
    
    Для хранения данных в программе применяются переменные.
    Переменная представляет именованный участок в памяти, который может 
    хранить некотоое значение. Для определения переменной применяется 
    ключевое слово var, после которого идет имя переменной, а затем 
    указывается ее тип:
    
    var hello string
    
    //Данная переменная называется hello и она представляет тип string, 
    //то есть некоторую строку
    
    var a, b, c string
    //В данном случае определены переменные a, b, c, которые имеют 
    //тип string. В этом случае опять же в конце указывается тип данных, 
    //и все переменные принадлежат этому типу
    
    var hello string - объявление переменной и задавание ей типа данных
    hello = "Good morning" - задаём значение созданной переменной
    fmt.Println(hello) - выводим её
    
    Также можно сразу при объявлении переменной присвоить 
    ей начальное значение. Такой прием называется инициализацией:
    		
    		var hello string = "Hello world"
        fmt.Println(hello)
    
    Если мы хотим сразу определить несколько переменных и присвоить 
    им начальные значения, то можно обернуть их в скобки:
    
    var (
    		name  string = "John"
    		lastName string = "Seemens"
    	)
    
    	fmt.Println(name)//John
    	fmt.Println(lastName)//Seemens
    
    Отличительной особенностью переменных является то, что их значение 
    можно многократно изменять:
    
    name     string = "John"
    		lastName string = "Seemens"
    	)
    
    	name = "Bagda"
    	lastName = "Aydinyan"
    
    	fmt.Println(name)
    	fmt.Println(lastName)
    
    Также допустимо краткое определение переменной в формате:
    (без использования var и указания типов данных)
    
    age := 10
    name := "Tom"
    
    Ключевые слова:break, case, chan, const, continue, default, defer, 
    else, fallthrough, for, func, go, goto, if, import, interface, map, 
    package, range, return, select, struct, switch, type, var
    ```
    
- ***Таблица типов данных***
    
    ### Целочисленные типы
    
    Ряд типов представляют целые числа:
    
    - int8: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)
    - int16: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
    - int32: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
    - int64: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)
    - uint8: представляет целое число от 0 до 255 и занимает 1 байт
    - uint16: представляет целое число от 0 до 65535 и занимает 2 байта
    - uint32: представляет целое число от 0 до 4294967295 и занимает 4 байта
    - uint64: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт
    - byte: синоним типа `uint8`, представляет целое число от 0 до 255 и занимает 1 байт
    - rune: синоним типа `int32`, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта
    - int: представляет целое число со знаком,
    которое в зависимости о платформы может занимать либо 4 байта, либо 8
    байт. То есть соответствовать либо
    int32, либо int64.
    - uint: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о
    платформы может занимать либо 4 байта, либо 8 байт. То есть
    соответствовать либо
    uint32, либо uint64.
    
    ```go
    var a int8 = -1
    var b uint8 = 2
    var c byte = 3  // byte - синоним типа uint8
    var d int16 = -4
    var f uint16 = 5
    var g int32 = -6
    var h rune = -7     // rune - синоним типа int32
    var j uint32 = 8
    var k int64 = -9
    var l uint64 = 10
    var m int = 102
    var n uint = 105
    ```
    
    ### Числа с плавающей точкой
    
    Для представления дробных чисел есть два типа:
    
    - float32: представляет число с плавающей точкой от 1.4*1045 до 3.4*1038(для положительных).
    Занимает в памяти 4 байта (32 бита)
    - float64: представляет число с плавающей точкой от 4.9*10324 до 1.8*10308 (для положительных) и
    занимает 8 байт.
    
    Тип float32 обеспечивает шесть десятичных цифр точности, в то время 
    как точность, обеспечиваемая типом float64, составляет около 15 цифр
    
    Примеры использования типов float32 и float64:
    
    ```go
    var f float32 = 18
    var g float32 = 4.5
    var d float64 = 0.23
    var pi float64 = 3.14
    var e float64 = 2.7
    ```
    
    ### Комплексные числа
    
    Существуют отдельные типы для представления комплексных чисел:
    
    - complex64: комплексное число, где вещественная и мнимая части представляют числа float32
    - complex128: комплексное число, где вещественная и мнимая части представляют числа float64
    
    Пример использования:
    
    ```go
    var f complex64 = 1+2i
    var g complex128 = 4+3i
    ```
    
    ### Тип bool
    
    Логический тип или тип bool может иметь одно из двух значений: true (истина) или false (ложь).
    
    ```go
    var isAlive bool = true
    var isEnabled bool = false
    ```
    
    ### Строки
    
    Строки представлены типом string. В Go строке соответствует строковый литерал - последовательность символов, заключенная в 
    двойные кавычки:
    
    ```go
    var name string = "Том Сойер"
    ```
    
    Кроме обычных символов строка может содержать специальные 
    последовательности (управляющие последовательности), которые начинаются с
     обратного слеша \. Наиболее 
    распространенные последовательности:
    
    - \n: переход на новую строку
    - \r: возврат каретки
    - \t: табуляция
    - \": двойная кавычка внутри строк
    - \\: обратный слеш
    
    При этом стоит учитывать, что если мы не указываем у переменной тип, то
    ей обязательно надо присвоить некоторое начальное значение. Объявление
    переменной одновременно без указания типа данных и начального значения
    будет ошибкой:
    
    ```go
    var name    // ! Ошибка
    ```
    
    Надо либо указать тип данных (в этом случае переменная будет иметь значение по умолчанию):
    
    ```go
    var name string
    ```
    
    Либо указать начальное значение, на основании которого выводится тип данных:
    
    ```go
    var name = "Tom"
    ```
    
    Либо и то, и другое одновременно:
    
    ```go
    var name string = "Tom"
    ```
    
- ***Константы***
    
    Для определения констант применяется ключевое слово const:
    
    ```go
    const pi float64 = 3.1415
    ```
    
    И в отличие от переменной мы не можем изменить значение константы. А
    если и попробуем это сделать, то при компиляции мы получим ошибку:
    
    ```go
    const pi float64 = 3.1415
    pi = 2.7182             // ! Ошибка
    ```
    
    В одном определении можно объявить разу несколько констант:
    
    ```go
    const (
        pi float64 = 3.1415
        e float64 = 2.7182
    )
    ```
    
    или так:
    
    ```go
    const pi, e = 3.1415, 2.7182
    ```
    
    Если у константы не указан тип, то он выводится неявно на основании того значения, которым инициализируется константа:
    
    ```go
    const n = 5     //  тип int
    ```
    
    В то же время необходимо обязательно инициализировать константу
    начальным значением при ее объявлении. Например, следующие определения констант являются недопустимыми, так как они не инициализируются:
    
    ```go
    const d
    const n int
    ```
    
    Если определяется последовательность констант, то инициализацию
    значением можно опустить для всех констант, кроме первой. В этом случае константа без значения полчит значение предыдущей константы:
    
    ```go
    const (
        a = 1
        b
        c
        d = 3
        f
    )
    fmt.Println(a, b, c, d, f)      // 1, 1, 1, 3, 3
    ```
    
    Константы можно инициализировать только константными значениями,
    например, литералами типа чисел или строк, или значениями других
    констант.Но инициализировать константу значением переменной мы не можем:
    
    ```go
    var m int = 7
    // const k = m      // ! Ошибка: m - переменная
    const s = 5     // Норм: 5 - числовая константа
    const n = s     // Норм: s - константа
    ```
    
- ***Арифметические действия***
    
    Язык Go поддерживает все основные арифметические операции, которые
    производятся над числами. Значения, которые участвуют в операции,
    называются операндами. Результатом операции также является число. Список поддерживаемых арифметических операций:
    
    - +
    
    Операция сложения возвращает сумму двух чисел:
    
    ```go
    package main
    import "fmt"
     
    func main() {
        var a = 4
        var b = 6
        var c = a + b
        fmt.Println(c)      // 10
    }
    ```
    
    - -
    
    Операция вычитания возвращает разность двух чисел:
    
    ```go
    package main
    import "fmt"
     
    func main() {
        var a = 4
        var b = 6
        var c = a - b
        fmt.Println(c)      // -2
    }
    ```
    
    - *
    
    Операция умножения возвращает произведение двух чисел:
    
    ```go
    var a = 4
    var b = 6
    var c = a * b   // 24
    ```
    
    - /
    
    Операция деления двух чисел:
    
    ```go
    var a int = 10
    var b int = 4
    var c int = a / b
    fmt.Println(c)      // 2
         
    var k float32 = 10
    var l float32 = 4
    var m float32 = k / l
    fmt.Println(m)      // 2.5
    ```
    
    При делении стоит быть внимательным, так как если в операции участвуют
    два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:
    
    ```go
    var m float32 = 10 / 4      // 2
    ```
    
    Результат представлял вещественное число, один из операндов также должен представлять вещественное число:
    
    ```go
    var m float32 = 10 / 4.0        // 2.5
    ```
    
    - %
    
    Возвращает остаток от деления (в этой операции могут принимать участие только целочисленные операнды):
    
    ```go
    var c int = 35 % 3      // 2 (35 - 33 = 2)
    ```
    
    - Постфиксный инкремент (x++). Увеличивает значение переменной на единицу:
    
    ```go
    var a int = 8
    a++
    fmt.Println(a)      // 9
    ```
    
    - Постфиксный декремент (x--). Уменьшает значение переменной на единицу:
    
    ```go
    var a int = 8
    a--
    fmt.Println(a)      // 7
    ```
    
- ***Условные выражения,Логические операции***
    
    Условные выражения представляют логические операции и операции
    отношения. Они представляют некоторое условие и возвращают значение типа bool:`true` (если условие истинно) или `false` (если условие ложно).
    
    - ==
    
    ```go
    package main
    import "fmt"
     
    func main() {
        var a int = 8
        var b int = 3
        var c bool = a == b
        fmt.Println(c)      // false
    }
    ```
    
    //Можно сравнивать только одинаковые типы данных
    
    - >
    
    Операция "больше чем". Возвращает true, если первый операнд больше второго, и false, если первый операнд меньше второго:
    
    ```go
    var a int = 8
    var b int = 3
    var c bool = a > b   // true
    ```
    
    - <
    
    Операция "меньше чем". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго:
    
    ```go
    var a int = 8
    var b int = 3
    var c bool = a < b   // false
    ```
    
    - < =
    
    Операция "меньше или равно". Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго:
    
    ```go
    var a int = 8
    var b int = 3
    var c bool = a <= b  // false
    ```
    
    - > =
    
    Операция "больше или равно". Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго:
    
    ```go
    var a int = 8
    var b int = 3
    var c bool = a >= b  // true
    ```
    
    - ! =
    
    Операция "не равно". Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны:
    
    ```go
    var a int = 8
    var b int = 3
    var c bool = a != b // true
    var d bool = a != 8 // false
    ```
    
    Логические операции сравнивают два условия. Как правило, они применяются к отношениям и объединяют несколько операций отношения. К логическим операциям относят следующие:
    
    - !(операция отрицания)
    
    Инвертирует значение. Если операнд равен true, то возвращает false, иначе возвращает true.
    
    ```go
    
    var a bool = true
    var b bool = !a     //false
    var c bool = !b     // true
    ```
    
    - &&(конъюнкция, логическое умножение)
    
    Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.
    
    ```go
    var b bool = 4 > 5 && 6 > 8       //false
    var c bool = 3 <= 5 && 10 > 8 // true
    ```
    
    - ||(дизъюнкция, логическое сложение)
    
    Возвращает true, если хотя бы один операнд не равен false. Возвращает false, если оба операнда равны false
    
    ```go
    var b bool = 4 > 5 || 6 > 8       //false
    var c bool = 3 == 5 || 10 > 8    // true
    ```
    
- ***Поразрядные операции***
    
    Поразрядные операции выполняются над отдельными разрядами чисел в
    бинарном представлении. Например, число пять в двоичной системе имеет
    три разряда: 101, а число восемь - четыре разряда: 1000.
    
    ### Операции сдвига
    
    И операции сдвига позволяют сдвинуть двоичное представление числа на
    несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:
    
    - <<(разряд увеличивается)
    
    Сдвигает битовое представление числа, представленного первым операндом,
    влево на определенное количество разрядов, которое задается вторым
    операндом.
    
    - >>(разряд уменьшается)
    
    Сдвигает битовое представление числа вправо на определенное количество разрядов.
    
    ```go
    var b int = 2 << 2;           // 10(2-ном коде 2 = 10)  на два разрядов влево = 1000 - 8
    var c int = 16 >> 3;          // 10000(2-ном коде 16 = 10000) на три разряда вправо = 100 - 2
    ```
    
    ### Поразрядные операции
    
    Поразрядные операции также проводятся только над разрядами целочисленных операндов:
    
    - &: поразрядная конъюнкция (операция И
    или поразрядное умножение). Возвращает 1, если оба из соответствующих
    разрядов обоих чисел равны 1. Возвращает 0, если разряд хотя бы одного числа равен 0(нужно умножить два числа в двоичной системе)
    - |: поразрядная дизъюнкция (операция ИЛИ
    или поразрядное сложение). Возвращает 1, если хотя бы один из
    соответствующих разрядов обоих чисел равен 1(нужно сложить два числа в двоичной системе)
    - ^: поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1(нужно сложить два числа в двоичной системе)
    - &^: сброс бита (И НЕ). В выражении `z = x &^ y` каждый бит z равен 0, если соответствующий бит y равен 1. Если бит в y равен 0, то берется значение соответствующего бита из x.(нужно делить два числа в двоичной системе)
    
    ```go
    package main
    import "fmt"
     
    func main() {
        var a int = 5 | 2;          // 101 | 010 = 111  - 7
        var b int = 6 & 2;          // 110 & 010 = 10  - 2
        var c int = 5 ^ 2;          // 101 ^ 010 = 111 - 7
        var d int = 5 &^ 6;         // 101 &^ 110 = 001 - 1
    }
    ```
    
- ***Массивы***
    
    Массивы представляют последовательность элементов определенного типа.
    
    Например, массив из пяти элементов типа int:
    
    ```go
    var numbers [5]int
    ```
    
    При таком определении все элементы массива инициализируются значениями
    по умолчанию. Но также можно инициализировать элементы массива другими значениями:
    
    ```go
    var numbers [5]int = [5]int{1,2,3,4,5}
    ```
    
    Значения передаются в фигурных скобках через запятую. При этом значений не может быть больше длины массива. В данном случае длина массива равна 5, поэтому нельзя в фигурных скобках определить больше пяти элементов.
    Но можно определить меньше элементов:
    
    ```go
    var numbers [5]int = [5]int{1,2}
    fmt.Println(numbers)    // [1 2 0 0 0]
    ```
    
    В этом случае элементы, для которых не указано значение, будут иметь значение по умолчанию.
    
    Также можно применять сокращенное определение переменной массива:
    
    ```go
    numbers := [5]int{1,2,3,4,5}
    ```
    
    Если в квадратных скобках вместо длины указано троеточие, то длина
    массива определяется, исходя из количества переданных ему элементов:
    
    ```go
    var numbers = [...]int{1,2,3,4,5}   // длина массива 5
    numbers2 := [...]int{1,2,3}         // длина массива 3
    fmt.Println(numbers)                // [1 2 3 4 5]
    fmt.Println(numbers2)           // [1 2 3]
    ```
    
    При этом длина массива является частью его типа. И, к примеру, следующие два массива представляют разные типы данных, хотя они и хранят дванные одного типа:
    
    ```go
    var numbers [3]int = [3]int{1, 2, 3}
    var numbers2 [4]int = [4]int{1, 2, 3, 4}
    numbers = numbers2  // ! Ошибка
    ```
    
    ### Индексы
    
    Для обращения к элементам массива применяются индексы - номера
    элементов. При этом нумерация начинается с нуля, то есть первый элемент
    будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:
    
    ```go
    package main
    import "fmt"
     
    func main() {
        var numbers [5]int = [5]int{1,2,3,4,5}
        fmt.Println(numbers[0])     // 1
        fmt.Println(numbers[4])     // 5
        numbers[0] = 87
        fmt.Println(numbers[0])     // 87
    }
    ```
    
    Индексы в массиве фактически выступают в качестве ключей, по которым
    можно обратиться к соответствующему значению. И в прицнипе мы можем явным образом указать, какому ключу какое значение будет соответствовать. При этому числовые ключи необязательно располагать в порядке возрастания:
    
    ```go
    colors := [3]string{2: "blue", 0: "red", 1: "green"}
    fmt.Println(colors[2])      // blue
    ```
    
- ***Условные конструкции***
    
    Условные конструкции проверяют истинность некоторого условия и в 
    зависимости от результатов проверки позволяют направить ход программы по
     одному из путей.
    
    ### if...else
    
    Конструкция if принимает условие - выражение, которое возвращает значение типа bool. И если это условие истинно, то выполняется последующий блок инструкций.
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        a := 6
        b := 7
        if a < b {
            fmt.Println("a is less than b")
        }
    }
    ```
    
    Условие ставится после оператора if. В данном случае проверяется, меньше ли значение переменной a чем значние переменой b. Поскольку в данном случае значение переменной a действительно меньше значения переменной b, то есть условие возвращает true, то будет выполнять последующий блок кода, который выводит на консоль сообщение.
    
    Если необходимо задать альтернативную логику, которая выполняется, в случае если условие неверно, то добавляется выражение else:
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        a := 6
        b := 7
        if a < b {
            fmt.Println("a меньше b")
        }else{
            fmt.Println("a больше b")
        }
    }
    ```
    
    Таким образом, если выражение после if истинно, то срабатывает блок if. Иначе проверяется выражение после else if. Если оно истинно, то выполняется блок else if. Если оно ложно, то выполняется блок else.
    
    Выражений else if может быть множество:
    
    ```go
    if a ==9 {
        fmt.Println("a = 9")
    }else if a == 8{
        fmt.Println("a = 8")
    } else if a == 7{
        fmt.Println("a == 7")
    }
    ```
    
    ### switch
    
    Конструкция switch проверяет значение некоторого выражения. С помощью операторов case
     определяются 
    значения для сравнения. Если значение после оператора case совпадает со 
    значением выражения из switch, то выполняется код данного блока case.
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        a := 8
        switch(a) {
            case 9: 
                fmt.Println("a = 9")
            case 8: 
                fmt.Println("a = 8")
            case 7: 
                fmt.Println("a = 7")
        }
    }
    ```
    
    В качестве выражения конструкция switch использует переменную a. Ее 
    значение последовательно сравнивается со значениями после операторов 
    case. Поскольку 
    переменная a равна 8, то будет выполняться блок `case 8: fmt.Println("a = 8")`. Остальные блоки case не выполняются.
    
    При этом после оператора switch мы можем указывать любое выражение, которое возвращает значение. Например, операцию сложения:
    
    ```go
    a := 7
    switch(a + 2) {
        case 9: 
            fmt.Println("9")
        case 8: 
            fmt.Println("8")
        case 7: 
            fmt.Println("7")
    }
    ```
    
    Также конструкция switch может содержать необязательных блок default, который выполняется, если ни один из операторов case не содержит нужного значения:
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        a := 87
        switch(a) {
            case 9: 
                fmt.Println("a = 9")
            case 8: 
                fmt.Println("a = 8")
            case 7: 
                fmt.Println("a = 7")
            default: 
                fmt.Println("значение переменной a не определено")
        }
    }
    ```
    
    Также можно указывать после оператора case сразу несколько значений:
    
    ```go
    a := 5
    switch(a) {
        case 9: fmt.Println("a = 9")
        case 8: fmt.Println("a = 8")
        case 7: fmt.Println("a = 7")
        case 6, 5, 4: 
            fmt.Println("a = 6 или 5 или 4, но это не точно")
        default: 
            fmt.Println("значение переменной a не определено")
    }
    ```
    
- ***Циклы***
    
    Циклы позволяют в зависимости от определенного условия выполнять некоторые действия множество раз. Фактически в Go есть только один цикл - цикл for, который может принимать разные формы. Этот цикл имеет следующее формальное определение:
    
    ```go
    for [инициализация счетчика]; [условие]; [изменение счетчика]{
        // действия
    }
    ```
    
    Например, выведем с помощью цикла квадраты чисел:
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        for i := 1; i < 10; i++{
            fmt.Println(i * i)
        }
    }
    ```
    
    Объявление цикла for разбивается на три части. Вначале идет инициализация счетчика: `i := 1`.
     Фактически она представляет 
    объявление переменной, которая будет использоваться внутри цикла. В 
    данном случае это счетчик i, начальное значение которого равно 1.
    
    Вторая часть представляет условие: `i < 10`. Пока это условие истинно, то есть возвращает true, будет продолжаться цикл.
    
    Третья часть представляет изменение (увеличение) счетчика на единицу.
    
    В теле цикла на консоль выводится квадрат числа i.
    
    Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:
    
    ```go
    var i = 1
    for ;i < 10; i++{
        fmt.Println(i * i)
    }
    ```
    
    Можно убрать изменение счетчика в само тело цикла и оставить только условие:
    
    ```go
    var i = 1
    for i < 10{
        fmt.Println(i * i)
        i++
    }
    ```
    
    ### Вложенные циклы
    
    Циклы могут быть вложенными, то есть располагаться внутри других циклов. Например, выведем на консоль таблицу умножения:
    
    ```go
    package main
    import "fmt"
     
    func main() {
         
        for i := 1; i < 10; i++{
            for j := 1; j < 10; j++{
                fmt.Print(i * j, "\t")
            }
            fmt.Println()
        }
    }
    ```
    
    ### Перебор массивов
    
    Для перебора массивов можно использовать следующую форму цикла for:
    
    ```go
    for индекс, значение := range массив{
        // действия
    }
    ```
    
    При переборе мы можем по отдельности получить индекс элемента в массиве и значение этого элемента. Например, перебирем массив строк:
    
    ```go
    var users = [3]string{"Tom", "Alice", "Kate"}
    for index, value := range users{
        fmt.Println(index, value)
    }
    //0 Tom
    //1 Alice
    //2 Kate
    ```
    
    Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк. Например, нам не нужны индексы:
    
    ```go
    for _, value := range users{
        fmt.Println(value)
    }
    ```
    
    Но также для перебора массива можно использовать и стандартную версию цикла for:
    
    ```go
    var users = [3]string{"Tom", "Alice", "Kate"}
    for i:= 0; i < len(users); i++{
        fmt.Println(users[i])
    }
    ```
    
    В данном случае счетчик i играет роль индекса. Цикл выполняется, пока счетчик i не станет равным длине массива, которую можно получить с помощью функции ***len()***
    
    ### Операторы break и continue
    
    Может возникнуть ситуация, когда нам надо при определенных условиях 
    завершить текущую итерацию цикла, не выполнять все инструкции цикла, а 
    сразу перейти к следующей итерации. В этом случае можно использовать 
    оператор continue. Например, в массиве могу быть,
     как положительные, так и отрицательные числа. 
    Допустим, нам нужна сумма только положительных чисел, поэтому, если нам 
    встретится отрицательное число, мы можем просто перейти к следующей 
    итерации с помощью continue:
    
    ```go
    var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
    var sum = 0
     
    for _, value := range numbers{
        if value < 0{
            continue        // переходим к следующей итерации
        }
        sum += value
    }
    fmt.Println("Sum:", sum)    // Sum: 27
    ```
    
    Оператор break полностью осуществляет выход из цикла:
    
    ```go
    var numbers = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var sum = 0
     
    for _, value := range numbers{
        if value > 4{
            break       // если число больше 4 выходим из цикла
        }
        sum += value
    }
    fmt.Println("Sum:", sum)    // Sum: 10
    ```