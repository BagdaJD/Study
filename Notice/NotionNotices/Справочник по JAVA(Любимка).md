# Справочник по JAVA(Любимка)

- **Введение**
    
    1.Все программы на Java состоят из классов
    
    2.Название созданного класса совпадает с названием файла
    
    Сигнатура того,как объявляется класс в Java :
    
    ```java
    public class HelloWorld {
       public static  void  main(String...args){
             System.out.println("Hello World"); - вызов метода main
        }
    }
    
    public - модификатор доступа,который показывает доступность 
    этого класса другим классам(в данном случаем этот класс доступен)
    
    class - ключевое слово,которое показывает ,что это класс
    
    HelloWorld - название класса
    
    main - нужен классу ,чтобы во время запуска происходило 
    какое-либо действие
    
    public static  void  main(String...args) - должна присутствовать 
    во всехпрограммах ,которые мы хотим запускать
    
    public static  void  main(String...args){} - вход в программу
    ```
    
    //psvm + tab - мы получим эту строчку public static  void  main(String...args)
    
    ```java
    System.out.println() - вывод чего либо
    System.exit(...) - возвоащает какое-то значение и завершает программу
    ```
    
- **Переменные**
    
    ## Переменные
    
    Чтобы объявить переменную в JAVA нужно - 
    
    1.Объявить её 
    
    2.указать тип данных 
    
    3.Указать имя
    
    4.Указать значение
    
    ```java
    public class integerManipulations {
        public static void main(String[] args) {
            int a = 5;
            int b = 7; - примеры объявления переменных
            int c = a + b;
    
           System.out.println("a + b =" + c);
        }
    }
    
    +  - сложение строк
    
    Если мы используем тип int  в вычеслениях ,
    то результат всегда будет тоже int (10/3 = 3, а не 3.3333)
    
    a = 10;
    b = 4;
    c = a%b; - получаем остаток от деления
    
    a += 5; - прибавляет 5 
    b -= 4; - отнимает 4
    a /= 5; - делит на 5 
    b *= 4; - умножает на 4
    a++; - прибавляет 1 (операция инкремента)
    a--; - отнимает 1 (операция динкремента)
    ```
    
- **Ввод информации**
    
    Для ввода информации в программу будем использовать библиотеку **Scanner**
    
    ```jsx
    import java.util.Scanner;
     
    public class Program {
       
        public static void main(String[] args) {
               
            Scanner in = new Scanner(System.in);
            System.out.print("Input a number: ");
            int num = in.nextInt();
              
            System.out.printf("Your number: %d \n", num);
            in.close();
        }
    }
    ```
    
    Для начала нужно её импортировать **(import java.util.Scanner;)** ,затем нужно создать объект класса **Scanner**.Использовать его и закрыть**(in.close();)**
    
    Класс Scanner имеет еще ряд методов, которые позволяют получить введенные пользователем значения:
    
    - **next()**: считывает введенную строку до первого пробела
    - **nextLine()**: считывает всю введенную строку
    - **nextInt()**: считывает введенное число int
    - **nextDouble()**: считывает введенное число double
    - **nextBoolean():** считывает значение boolean
    - **nextByte():** считывает введенное число byte
    - **nextFloat()**: считывает введенное число float
    - **nextShort():** считывает введенное число short
    
    ```jsx
    import java.util.Scanner;
     
    public class Program {
       
        public static void main(String[] args) {
               
            Scanner in = new Scanner(System.in);
            System.out.print("Input name: ");
            String name = in.nextLine();
            System.out.print("Input age: ");
            int age = in.nextInt();
            System.out.print("Input height: ");
            float height = in.nextFloat();
            System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
            in.close();
        }
    }
    ```
    
- **Условный оператор**
    
    ### If/else
    
    Условный оператор возвращает либо true , либо false
    
    ```java
    public class temperature {
        public static void main(String[] args) {
            int temp = 21;
    
            if(temp > 25) { - условие
                System.out.println("Кондиционер включён");
            }else if(temp < 22){ - вводим доп.условие
                System.out.println("Кондиционер выключён");
            }else { - если ни какое условие не вернет true
                System.out.println("Кондиционер ничего не делает");
            }
        }
    }
    
    Пример условного оператора в JAVA
    ```
    
    ### Switch/case
    
    ```jsx
    switch(numOfMonth){ - пишем изменяемую переменную
                case 1 : - условие
                    System.out.println("hello"); - выполнение
                    break; - нужно писать обязательно ,иначе программа
    													не будет проверять другие условия
                case 2:
                    System.out.println("Goodbye");
                default: - выполнится в любом случае
                    System.out.println("ok"); 
            }
    Пример - 
    switch (nameOfMonth){
                case "Январь","Февраль","Декабрь":
                    System.out.println("Зима");
                    break;
                case "Март","Апрель","Май":
                    System.out.println("Весна");
                    break;
                case "Июнь","Июль","Август":
                    System.out.println("Лето");
                    break;
                case "Сентябрь","Октябрь","Ноябрь":
                    System.out.println("Осень");
                    break;
                default:
                    System.out.println("Error");
            }
    
    nameOfMonth.equals(seconds) - сравнение строк
    ```
    
- **Типы данных**
    
    ### Целые числа
    
    1. **int** -  *занимает 4 байта (много цифр хранит).Повседневно используется*
    2. **byte** - *занимает 1 байт (-128 до 127).Полезно с ним работать с файлами из интернета*
    3. **long** - занимает 8 байт(оченььь много).Тоже часто используется
    4. **short** - *2 байта занимает (-32768 до 32767).Используется очень редко*
    
    ### Числа с плавающей точкой
    
    1. **float** - *4 байта имеет не очень большую точность(0.234)*
    2. **double** -  *8 байт имеет большую точность(0.0921029)*
    
    ### Символы(строки)
    
    1. **char** - *символьный тип(строка)*
    
    ### Логические переменные
    
    1. **boolean** - *true или false*
    
    ### Важно знать
    
    1. Нельзя проводить какие-либо ариф.вычесления с разными типами данных
    2. Суть такова - можно присвоить тип данных меньшего к большему типу(но не наоборот)
    
    ```java
    int speed = 300000;
    long seconds = days * 24 * 60 * 60;
    
    long distance = speed * seconds;
    
    В данном случаем не будет ошибки так ,
    как long seconds(много) хранит в себе большее значение 
    чем speed(30000).
    
    **!Следовательно в переменную будет возвращаться тот тип данных,
    у которого в данном случае переменная имеет большее значение !**
    -----------------------------------------------------------------
    int speed = 300000;
    long seconds = days * 24 * 60 * 60;
    
    long distance = speed * seconds; - выводит большое число 
    
    Но если написать так - 
    
    int speed = 300000;
    int seconds = days * 24 * 60 * 60;
    
    long distance = speed * seconds; - то выведет отрицательное число
    ,то есть не правильный ответ.
    Из-за того,что speed и seconds имеет
    тип данных int,значит и distance будет возвращать этот тип данных.
    И т.к. int не может в себе хранить такие значение будет неправильный
    ответ.
    Но происходят вычесления из-за автоматического приведения типов.
    То есть,программа видит ,что мы типу long присваиваем два типа int 
    во ремя вычеслений и переобразует его в int,так 
    ,как int меньше занимает памяти.
    ------------------------------------------------------------------
    byte a = 10;
    int b = a; - это получается из-за того,что byte весит меньше 
    чем int
    
    **но**
    
    int a = 10;
    byte b = a; - будет ошибка из-за того,что мы пытаемся больший 
    тип данных привести к меньшему
    
    byte b = (byte)a;
    
    byte a = 15;
    int b = (byte)a; - указываем какое значение типа данных 
    мы хотим записать в ()
    ```
    
    ### Float и Double
    
    ```java
    double pi = 3.14; - пример объявления переменной с типом
    данных double
    
    float r = 10.8f; - пример объявления переменной с типом
    данных float
    //Обязательно написать f после числа
    ```
    
    ### Char
    
    ```java
    char chi = 88; - пример объявления переменной с типом
    данных char(с помощью кодировки символов)
    
    char chi2 = 'w'; - пример объявления переменной с типом
    данных char(с помощью символов)
    ```
    
    ### Boolean
    
- **Циклы**
    
    ### While
    
    ```java
    int i = 1; - переменная счётчик
            while (i <= 1000){ - условие выполнения цикла
                System.out.println(i);
                i++; - сами операторы
                if (i == 5){
                    break;
                }
            }
    break - прекращает работу цикла(например) при каком либо 
    условии или без него 
    ```
    
    ### Do While
    
    ```java
    int i = 0;
            do {
                System.out.println("hello");
            }
            while (i > 0);
        }
    
    Единственное отличие этого цикла от While в том ,что 
    часть do всегда выполнится,а лишь потом уже будет прове-
    ряться условие.
     
    ```
    
    ### For
    
    ```java
    for(int i = 0; i < 100; i++){
                if(i % 2 == 0){
                    System.out.println(i);
                }
            }
    
    1.Создаём перемнную счётчик(i)
    2.Пишем условия выполнения
    3.Изменяем переменную счётчик(i++,i--)
    
    //Лучше использовать для действий ,которые мы знаем 
    //сколько раз булдут исполняться
    
    //после i можно объявить ещё одну переменную через запятую
    ```
    
    ### ForEach
    
    ```jsx
    for (int i : nums){
                System.out.println(i);
          }- все значения массива поочерёдно будут присваиваться i
    ```
    
    //ForEach - стоит использовать если мы не собираемся изменять массив и не присваивать в его ячейки новые значения
    
- **Массивы**
    
    ## Массивы
    
    ```java
    int[] daysInMonth = new int[12]; - пример
    
    1.Указываем какой тип данных будет хранить массив
    2.Называем массив
    3.Указываем кол-во значений в нём
    
    daysInMonth[0] = 31; - задаём значение индексу массива
    daysInMonth[1] = 28; /
    
    daysInMonth.length - показывает длину массива
    
    new - ключевое слово ,которое делает так ,чтобы если 
    индексам массива не были указаны значения ,то он выведет
    значение по умолчанию + это зависит от какого типа данных 
    будет хранить всебе массив(если int ,то по умолчанию ,
    то булут 0,если boolean ,то false и т.д.)
    
    int[] daysInMonth = new int[12];
    
    for (int i = 0; i < daysInMonth.length; i++){
                System.out.println(daysInMonth[i]);
            } - здесь выведется 12 нулей
    
    -----------------------------------------------------
    
    int[] dayOfMonth = {31,28,31,30}; - ещё один доп вариант создания 
    массива
    ```
    
    ### Алгоритм добавления и убирания элементов в массиве
    
    ```java
    				String[] employeess = {
                    "Tigran",
                    "Egor", - изначальный массив
                    "Misha",
                    "Petya"
            };
            String[] second = new String[employeess.length+1];- длина чтарого массива +1,для нового эл-та
            for (int i = 0;i<employeess.length;i++){ - добавление нового элемента 
                second[i] = employeess[i];                    в массив
            }
    				second[second.length-1] = "Ivan"; 
    				employeess = second
    ---------------------------------------------------------------------------------
            employeess[1] = null; - присваиваем null ,удаляемому элементу
            String[] third = new String[employeess.length-1];
            for( int i = 0,j = 0;i<employeess.length;i++){ - убираем лемент из массив
                if (employeess[i] != null){
                    third[j] = employeess[i];
    								j++;
                }-перебираем старый массив и все эл-ты,которым мы присвоили null не добавляем
            }
    				employeess = third;
    ```
    
- **String**
    
    ### String(работа со строками)
    
    ```jsx
    String name = "Bagda"; - пример объявления переменной с типом данных 
    строкой
    
    String result = "Привет, " + name + "\nтебе " + age;
    
    \n - перенос на новую строчку
    \" \" - для экранизирования ковычки(вывода в консоль)
    
    String result = "Привет, \"" + name + "\"\nтебе " + age;
    
    String string = "Java";
    String substring = "va";
    
    System.out.println(string.contains(substring));
    string.contains(substring) - проверка содержит ли та или иная строка символы
    string.equals(substring); - проверка на одинаковость строк
    ```
    
- **ООП**
    
    ## Введение в ООП
    
    **Класс** - это набор каких-либо свойств(своего рода шаблон)
    
    А **объект(экземпляр класса)** - это что-то конкретное,созданное на основе класса
    
    **Классы** содержат какие-либо данные***(их называют ещё переменные экземпляра или поля)*** ,а также код,действия ,которые может выполнять данный объект***(методы)***
    
    А всё содержимое класса называется **членами класса**
    
    ```java
    class nameClass{
    	int num = 1;
      String hum = "Human";
    	....
    	void method();
    	...
    } - пример того как выглядит класс
    ```
    
    Чтобы создать **объект** ,нужно создать класс **main** ,с которого наша программа будет запускаться,дальше другой класс ,в котором мы будем описывать будущие **объекты(информацию о них)** и затем пишем вот это -
    
    ```java
    //main.java
    public class main {
        public static void main(String[] args) {
            box myBox; - создаем переменную ссылочного типа,
    которая в дальнейшем станет объектом использую класс box
    
            myBox = new box(); - инициализа объекта по классу box
       *(можно было это присвоить сразу при объявлении переменной*)
    
            myBox.height = 10.2;
            myBox.length = 15.84; 
            myBox.height = 14.9; - присваивание этому объекту 
    данных значений ,указанных в классе
        }
    }
    
    //box.java
    public class box {
        double width;
        double height;
        double length;
    }
    
    //переменная ссылочного типа - это переменные ,которые 
    //ссылаются на объект класса
    
    box box4 = new box();
    box box3 = box4; - эти переменные будут ссылаться
     на один и тот же объект
    ```
    
- **ООП.Методы**
    
    *тип(int,bool etc.) имяМетода(список параметров(могут быть какие-то переменные)){*
    
    *тело метода*
    
    *}* - пример метода
    
    А если метод ничего не возвращает,то тип указываем -  **void**
    
    Также если тип метода не **void ,**то этот метод должен что-то возвращать -
    
    return значение;
    
    //При этом метод должен возвращать тот тип данных , который у него указан при его создании
    
    ```java
    void showVolume(){
            double volume = width * height * length;
            System.out.println(volume);
        } - пример без возврата
    
    box1.showVolume(); -- вызовы метода
    box2.showVolume(); /
    
    double Volume(){
       return width * height * length;
        } - пример с возвратом данных
    ```
    
    ## Параметризированные методы
    
    ```java
    int square(int i){ - параметр
            return i*i;
        } - пример
    
    double width;
    double height;
    double length;
    
        void setDimense(double width, double height, double length){
            this.width = width;
            this.height = height;
            this.length = length;
        } - this.width ссылается на перем. width ,
         а не на параметр width(ну и т.д.)
    
    //т.к. width(без this) в данном случае параметр 
    //,который находится внутри метода
    
    //В данном случае мы с помощью this ссылаемся на 
    //переменную и приравниваем её к параметру 
    ```
    
- **Конструкторы**
    
    *//Конструкторы могут быть с параметрами и без параметров*
    
    *//Если в классе мы не создали конструктор ,то java по умолчанию его создаёт, и присваивает всем полям знач. по умолчанию*
    
    ```java
    box(){ - пример конструктора
            width = 10;
            height = 10;
            length = 10;
        }
    ```
    
    ```java
    box box = new box(); - вызов класса(конструктора)
    ```
    
- **Перегрузка методов и конструкторов**
    
    ### Перегрузка методов
    
    //Один класс может иметь несколько методов ,с 
    
    //условием того,что они будут разных типов данных или с //разным кол-во параметров их типов данных
    
    ```java
    test.java
    
    int multitype(int a, int b){
            return a*b;
        }
    
    double multitype(double a, double b){
            return a*b;
        }
    
    //Это облегчает нам работу
    
    main.java
    
    test test = new test();
    
    double result = test.multitype(6.3,5.8);
    
    System.out.println(result);
    
    //позволяет грубо говоря одним методом всё вычеслить
    ```
    
    //static - позволяет не создавать объект при использовании метода того или иного класса
    
    //Лучше всего писать static если метод не использует экземпляры класса или прочие переменные,а только параметры внутри метода и если ,что-то возвращает
    
    ```java
    test.java
    static int multitype(int a, int b){
            return a*b;
        }
       static double multitype(double a, double b){
            return a*b;
        }
    
        static int multitype(int a){
            return a*a;
        }
    
    main.java
    
    int result = test.multitype(5);
    System.out.println(result);
    
    //Просто создаём переменную,затем пишем название класса
    //ставим точку и пишем название метода
    ```
    
    ### Перегрузка конструкторов
    
    //Также как и у методов ,конструкторы с одним названием должны будут отличаться кол-вом параметров
    
    ```java
    box(){
            width = 0;
            height = 0;
            length = 0;
        }
    
        box(double size){
            width = size;
            height = size;
            length = size;
        }
    ```
    
    Также можно использовать один метод в другом
    
    ```java
    void showVolume(){
            System.out.println(volume());
        }
    
        double volume(){
            return width*height*length;
        }
    ```
    
- **Доп.инфа объекты как параметры**
    
    ```java
    box.java
    
    void compare(box box){
            double thisVolume = volume();
            double boxVolume = box.volume();
    
            if (thisVolume > boxVolume){
                System.out.println("Наша каробка больше");
            }else if (thisVolume < boxVolume){
                System.out.println("Наша каробка меньше");
            }else {
                System.out.println("Каробки равны");
            }
        }
    
    main.java
    
    box box  = new box(10,10,10);
    box box1 = new box(3,5,6);
    
    box.compare(box1);
    ```
    
    //В данном случае берутся данные объекта ,который этот метод вызывает и данные объекта ,который идёт в роли параметра(вот так и происходит сравнение)
    
    ```java
    //Также это сравнение можно переделать вместо void в
    // возвращаемый метод
    
    int compare(box box){
            double thisVolume = volume();
            double boxVolume = box.volume();
    
            if (thisVolume > boxVolume){
               return 1;
            }else if (thisVolume < boxVolume){
                return -1;
            }else {
                return 0;
            }
        }
    ```
    
    ```java
    box box1 = new box(10); - это два разных объекта ,но с одними и теми же значениями
    box box2 = new box(box1); / 
    box1.setDimense(10,10,100); - это мы показываем за счёт этого
    ```
    
    //Заметка
    
    ```java
    box increase(int i){
      return new box(width*2,height*2,length*2);
        }
    ```
    
- **Модификаторы доступа.Сеттеры и Геттеры.Пакеты**
    
    ***public*** - модификатор доступа,который даёт доступ тому элементу ,к которому он указан
    
    ```java
    ----------Пример public
    
    man.java
    
    public String name;
    public int age;
    
    main.java
    
    man man = new man("Ivan", 18);
    man.name = "...";
    man.age = 17;
    
    //public - разрешает изменять указанные элементы(методы,поля класса и т.д.))
    //то,есть даёт доступ на изменения их
    ```
    
    ```java
    ---------------Пример private
    
    man.java
    
    private String name;
    private int age; - а тут мы можем их изменять и т.д.
    
    main.java
    
    man man = new man("Ivan", 18);
    
    //man.name = "..."; - уже не получтся изменить или вызвать тот метод
    //man.age = 17; - или поле класса
    ```
    
    ***private*** - модификатор доступа ,который даёт возможность пользоваться тем или иным элементом,только в том классе в котором он объявлен
    
    ***Для того,чтобы изменить значение переменной с private,есть сеттеры***
    
    ```java
    //то есть мы поменяем значение этой переменной не напрямую 
    //обращение с ней ,а через сеттер
    
    man.java
    public void setAge(int age){
            if(age > 0) {
                this.age = age;
            }else {
                System.out.println("Возвраст должен быть больше");
            }
    
    main.java
    man man = new man("Ivan", 21);
    man.setAge(22); - вводим новый возвраст
    man.showInfo(); - выведет Ivan 22
    
    ```
    
    ***Для того,чтобы получить значение переменной с private,есть геттеры***
    
    ```java
    man.java
    private int age;
    public int getAge(){
            return age;
        }
    
    main.java
    man man = new man("Ivan", 21);
    System.out.println(man.getAge()); - 21
    ```
    
                                                **Инкапсуляция**
    
     **Инкапсуляция** - это сокрытие реализации(кароче говоря)
    
                  **Два основных правила модификаторов доступа**
    
                               **1.**Все возможные поля - **private**
    
                   **2.**Методы,которые используются другими классами - **** **public**,остальное **private**
    
                                    **Пакеты(папочки)**
    
    //Чтобы создать нажимаем new - package - называем(с маленькой буквы)
    
    //Также не стоит создавать одноименный классы и пакеты
    
    А чтобы импортировать один класс из пакета в другой ,то 
    
    ```java
    package main;
    import test.man; - сначала import,затем название пакета и после
    название класса
    
    public class main {
        public static void main(String[] args) {
            man man = new man("Ivan", 21);
            System.out.println(man.getAge());
        }
    ```
    
                 —————***Нужны для лучшей классификации классов———————***
    
    ***default*** - модификатор доступа,который будет считаться ***public*** ,если поля класса,методы используются в пределах пакета ,в котором этот класс находится и будет считаться ***private*** ,если попытьаться использовать поля класса,методы в других классах,которые не находятся в одном пакете(этот модификатор доступа стоит по умолчанию у всех элементов ,у которых не казан явный модификатор доступа)(но лучше использовать чаще **public** и **private**)
    
- **Final и Static.Переменная длины**
    
    ***static*** - позволяет без создания объекта использовать метод
    
    //Стоит его использовать если в методе не используются поля класса
    
    ```java
    myMath.java
    public static int square(int num){
            return num*num;
        } - без изпользования полей класаа        
    
    main.java
    
    int square = myMath.square(20);
    System.out.println(square);
    
    ```
    
    //***static*** - может использовать ,только поля класса с ***static***,т.к. статичные методы относятся к классу ,а не к объекту
    
    //т.к статичные переменные относятся к классу ,а не к объекту ,то она может изменяться в статичных методах***(не только в методе она поменяется,но и во всем классе)***
    
    ```java
    myMath.java
    private static double pi = 3.14;
    
    public static double length(double radius){
        return  radius*2*pi;
      }
    
    .......
    myMath.java
    public static double square(double radius){
            return radius*radius*PI;
        }
    
    public static double length(double radius){
    				PI = 10;
            return radius*2*PI;
    }
    
    main.java
    int square = MyMath.square(10);//314
    int square1 = MyMath.length(10);//2000 уже неправильно НО
    int square2 =  MyMath.square(10);//1000 значение PI поменялось ,что изменило работу метода
    ```
    
    **final** - говорит о том,что у элемента указано финальное значение(то есть ,второй раз не получится установить новое значение)
    
    //Если мы пишем **final** ,то принято называть этот элемент заглавными буквами
    
    ```java
    private static **final** double PI = 3.14;
    
    public static double length(double radius){
            return  radius*2*PI;
        }
    ```
    
                                     ***Правила использования*** **static**
    
    **1.*Если метод использует ,только свои параметры или переменные внутри себя***
    
    **2.*Если метод использует экземпляр класса ,который используется ,только в методах* static *и у этого поля класса есть* static**
    
    **3.*Относится к классу ,а не объекту***
    
    ## Переменная длины
    
                                       Своего рода псевдомассив
    
    Пример удобного использования(замена массива) - 
    
    ```java
    public int sum(int... numbers){ - сначала тип данных,затем много-
    точие и после, название
            int sum = 0;
            for (int i : numbers) {
                sum += i;
            }
            return sum;
        }
    ```
    
    //В данном случаем нам облегчает это задачу тем , что не будет необходимости создавать массив и передовать его ,как параметр
    
    //int... numbers - позволяет при вызове метода вводить сколько хочешь параметров
    
- **Коллекции.Втроенные коллекции**
    
    **Коллекции** - это набор однотипных объектов(те же массивы ,но удобнее)
    
    //Если массив создан ,то его размер без прямого изменения,изменить не получится
    
    ```java
    import java.util.ArrayList;
    
    ArrayList emploes = new ArrayList(); - создание коллекции в виде
    объекта
    
            (вот его указание)
    ArrayList<String> emploes = new ArrayList<>(); - также можно указать
    какой тип данных именно будет хранить в себе коллекция
    
    emploes.add("Nikola");
    emploes.add("Lecha");
            for(int i = 0; i < emploes.size(); i++){
                System.out.println(emploes.get(i));
            } - также работает ,как наша коллекция
    //имеет методы add,get,size,remove
    
    //В отличии от нашей коллекции ,внутреннюю коллекцию можно пере-
    //бирать с помощью forEach,также ,как и обычный массив
    
    **Во внутренние коллекции нужно писать ссылочный типы или же оболоч-
    ку типа для примитивного типа**
    
    ArrayList<Integer> num = new ArrayList<>();
    
    //В тип данных ,который будет хранить в себе коллек-
    //ция можно написать и название объекта,которая она
    //будет хранить ,также можно напимать родительский
    //класс этих дочерних классов и тогда в коллекции можно 
    //хранить объекты разных дочерних классов
    
    А чтобы перебрать эту коллекцию ,надо написать типо
    такого
    
    ArrayList<animals> animals = new ArrayList<>();
    animals.add(dog);
    animals.add(cat);
    animals.add(fish);
    animals.add(bird);
    
    for (animals animal : animals){
                animal.eat();
            }
    ```
    
    ```java
    Чтобы использовать коллекции помимо класса  main ,нужно в классе 
    создать блок инициализации - 
    public ArrayList<String> list = new ArrayList<>();
    
       {
          list.add("arr"); - типо такого
       }
    ```
    
                           **Когда лучше использовать массивы ,а когда коллекции?**
    
                                      ***Всегда стоит использовать коллекции ,но***
    
    ***стоит использовать массив ,если мы точно знаем,что он не будет изменяться***
    
    ## Остальные коллекции
    
    ```java
    HashSet<String> names = new HashSet<>();
    //1.Эта коллекция не может хранить в себе одинаковых значений,
    //даже если мы их и укажем
    //2.Мы не сможем обратиться к этим элементам коллекции
    через метод get ,но только через forEach
    //3.Данные хранятся в разбросанном виде
    
    ------------------------------------------------------
    
    TreeSet<String> names = new TreeSet<>();
    //Такая же коллекция ,как HashSet ,но только хранит данные в 
    //в нормальном порядке
    //Работает чуть медленнее чем HashSet
    ```
    
    ## HashMap
    
    **HashMap** - коллекция ,которая может хранить в себе данные по типу **ключ - значение**  
    
    ```java
    HashMap<Integer,String> arr = new HashMap();
    arr.put - аналог .add(x) - для ArrayList
    Всё остальное тоже самое,только вместо индекса пишем ключ
    //
    Чтобы получить значение из HashMap нужно обратиться к ключу значения
    то есть - 
    {12="one",21="two",13="three"}
    Чтобы получить значение "three" нужно написать:
    arr.get(13) - то есть внутри скобок пишем ключ
    Аналогично и с другими
    //
    Чтобы сделать цикл по **HashMap** нужно написать - 
    for(int(тип данных ключа) key : arr.keySet){
    					.........
    }
    arr.keySet() - возращает массив ключей из коллекции **HashMap** 
    arr.values() - возвращает массив значений из коллекции **HashMap**   
    ```
    
- **import.Продвинутая работа со строками.Перевод одного типа данных в другой.Регулярные выражения**
    
    //Math - автоматически импортируется в класс
    
                                      ***Оболочки типов***
    
    У каждого примитивного типа данных(int,long...) есть свой анолог ссылочного типа*(Они пишутся с большой буквы)*
    
    У int - Integer(Оболочка типа)
    
    ```java
    int a = 5;
    Integer b = 5; - одно и то же
    byte d = 2;
    Byte f = 2;
    char fg;
    Character hg; - мини искл в написание
    ```
    
    //При том ,что сначала объявляется переменная ссылочного типа ,а затем уже примитивный тип туда “упаковывается”.Это называется автоматической упаковкой
    
    ***//Лучше всегда использовать примитивные переменные,а их оболочки(ссылочные переменные) если они нужны,т.к  ссылочные типы потребляют больше ресурсов***
    
    ```java
    String s = "1000";
    String f = "2000";
    int g = Integer.parseInt(s);
    int y = Integer.parseInt(f);
    
    String f = "False";
    boolean d = Boolean.parseBoolean(f);
    
    Integer.parseInt(); - принимает параметр строку
    и преобразует её в число
    
    Boolean.parseBoolean(); - принимает параметр строку
    и преобразует её в логическое значение(но может принимать 
    строку ,которая хранит либо true или false или какие-либо значения 
    ,но они будут считаться false)
    ```
    
    **//И такие преобразователи есть у каждого типа данных(название типа с большой буквы,затем точка ,ну и потом что-то типа parseInt и т.д.)**
    
    ```java
    String info = "His name igor,he is programmer";
    String s = info.substring(4);- обрезает строку
    info с 4-го элемента
    System.out.println(s); - name igor,he is programmer
    
    substring() - **метод ,который обрезает строку с 
    какого-то индекса по какой-то,которые мы сообщаем 
    ,как параметры**(принимает 1 - 2 парам)
    //Счёт идёт с нуля и пробелы тоже считаются
    ```
    
    ## Регулярные выражения
    
    ```java
    String regex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[_])[A-Za-z\\d_]{1,20}$";
    
    ```
    
    - **Наследование.Абстрактные классы**
        
        С помощью наследования можно создавать **иерархию классов**
        
        Сначала идет родительский класс**(суперкласс)**,а затем уже от него дочерние классы**(подклассы)**
        
        ```java
        catFamily.java
        
        catFamily(){
                ears = 2;
                legs = 4;
                bigClavs = true;
            }
        
        cat.java
        
        public class cat extends catFamily{
            public cat(){
        				//ears = 2;legs = 4;
                bigClavs = false; - мы изменили для этого класса,только это
        				поле
            }
        }
        
        extends - показывает от какого класса наследуется этот(В данном 
        случае класс cat наследуется от catFamily)
        //При наследовании все поля класса доступны дочерним классам от 
        //родительского и значения этих полей ,также наследуются,но в 
        //дочерних классах можно эти значения изменять в конструкторах
        
        //Также если мы установим private переменным родительского класаа
        //то даже дочерние классы не смогут получить к ним доступ - нужно делать
        //сеттеры***(в родительском классе)***
        
        //Но всё это можно сделать и в конструктуре
        
        catFamili.java
        
        public catFamily(int ears, int legs, boolean bigClavs) {
                this.ears = ears;
                this.legs = legs;
                this.bigClavs = bigClavs;
            }
        
        cat.java
        
        public class cat extends catFamily{
            public cat(){
                super(2,4,false);
            }
        }
        
        //То есть ,чтобы вызвать конструктор родительского класса надо,
        //написать ***super*** и передать туда указанные параметры
        
        *//У дочерних классов по умолчанию вызывается конструктор 
        родительского класса без параметров
        
        --!Если в родительском классе нет конструктора без параметров ,то!--
        	Первым делом в дочерних классах ,нужно внутри конструктора 
        								вызвать родительский конструктор*
        ```
        
        ```java
        Можно также преопределать методы родительского класса
        
        catFamily.java
        
        public void eat(){
                System.out.println("Кушаю еду");
            } - по умолчанию будет у всех дочерних классов
        
        cat.java
        
        @Override
            public void eat(){
                System.out.println("Кушаю вискас");
            } - при вызове этого метода у объекта cat,будет выводиться
         "Кушаю вискас" ,а не "Кушаю еду"
        
        @Override - само по себе ничего не делает ,но помогает понять, что
        этот метод переопределяет родительский метод и выводит ошибку,если
        мы например не правильно ввели название переопределяемого метода
        (собственно ,так и переопределяются методы :3)
        
        cat.java
        
        super.eat(); - вызывает метод у родительского класса уже в дочернем
        классе(то есть,если нужно вызвать метод у родительского класса в 
        дочернем ,то пишем super)
        
        //Если метод в род.классе подчти не используется и 
        //всегдя переопределяется в дочерних классах,то его надо сделать абстрактным
        
        public abstract double square();
        
        //То есть всю реализацию мы убираем из родительского элемента
        
        Но ,если мы имеем абстрактный метод,то и класс то же будет абстрактным
        public abstract class Figure{...}
        
                  **------------Абстрактные классы----------
        *Если мы хотим ,чтобы какой-либо класс был только родительным и
        ничего не делал в main.java,то делаем его абстрактным ,а методы 
        ,которые в дальнейшем будут преобразовываться,тоже будут 
        абстрактными
        
        !*И если переопределяемый абстрактный метод не был переопределён в 
        дочернем классе,то будет ошибка*!
        
        Также не будем забывать ,что можно будет создавать иерархию классав
        И получается ,что дочерний класс уже существующего дочернего класаа,
        унаследует все поля классов и их методы и србственно сможет их пере-
        определить
        А если мы не хотим ,чтобы методы переопределялись ,то пишем final
        
        Также если мы напишем классу final,тем самым мы запрещаем наследоваться 
        от этого класса
        
        ---------------------------------------------------*
        
        Мы не сможем создать объект абстрактного класса,но
        сможем создать объект дочернего класса
        
        animals animal = new dog();**
        
        И интерфейсы(но тогда в коллекцию можно будет добав-
        ить только те объекты,которые имеют те или иные методы
        интерфейса)
        ArrayList<CanRun> animals = new ArrayList<>();
        ```
        
- **Интерфейсы**
    
    ```java
    Абкаст - приведение объекту родительского класса
    ,дочернего объекта
    
    Даункаст - приведение объекту дочернего класса
    ,родительского объекта
    
    dog1 = (dog)animals1;
    
    Тут уже автоматически даункаст не происходит,нужно
    явно указать тип объекта ,в который переобразовываем
    
    //Можно объекту родительского абстрактного класса,
    //присвоить объект дочернего класса
    
    animals animals1 = dog1;
    
    animals - род. и абстрактный класс
    dog1 - его дочерний класс
    
    //Будет ошибка если мы постараемся вызвать метод дочернего класса 
    //,у родительского ,если у него не будет этого метода
    
    dog dog1 = new dog();
    dog1.run();
    animals animals1 = dog1;
    animals1.run(); - ошибка
    ```
    
    ## Интерфейсы
    
     ***Интерфейсы*** - показывают ,что должны делать те или иные объекты
    
    ***Интерфейсы*** ,это по сути ,тоже абстрактные классы ,которые имеют в себе только методы
    
    ```java
    public interface CanRun { - пример интерфейса
        void run(); - в методвх интерфейса не нужно 
              указывать модификатор доступа public,он 
              устанавливается по умолчанию
    }
    
    Чтобы реализовать интерфейс в других классах 
    нужно написать-
    
    public class cat extends animals implements CanRun{}
    implements - реализуется этот интерфейс(CanRun)
    
    Будет ошибка ,если мы попытаемя реализовать интерфейс
    в классе ,в котором нету метода ,который есть в привязанной 
    интерфейсе
    
    CanRun.java
    public interface CanRun {
        void run();
    
    bird.java
    public class bird extends animals implements CanRun{
        @Override
        public void eat() {
            System.out.println("Ем птичий корм");
        }
    } - Будет ошибка,пока мы не добавим сюда метод run
    
    Добывим это и бует правильно - 
    @Override
        public void run() {
            ...
        }
    
    //В отличии от наследования классов,интерфейсы 
    //можно наследовать сколько хочешь
    
    ```
    
- **Анонимные классы**
    
    ```java
    Анонимные классы стоит использовать ,чтобы - сэкономить время и 
    если тот или иной объект(метод) используется один раз в программе
    
    director.force(new Cookable() { - интерфейс
                @Override - переопределение метода этого интерфейса
                public void cook() { - именно для этого отрывка кода
                    System.out.println("Готовлю");
                } - нигде кроме этого места переопределение не произойдет
            });(не в классах ,где реализуется этот интерфейс и т.д.)
    ```
    
- **Обработка исключений**
    
    ```java
    int a = 0;
    int b = 7 / a; - исключение(ошибка)
    System.out.println("Hello");
    ```
    
    ***Исключения*** - это такие участки кода ,в которых есть возможность возникновения аварийной ошибки(вылета)
    
    ```java
    int a = 0;
            try{
                int b = 7 / a; - если этот участок кода не выполнится
            }catch (ArithmeticException e){ - то программа 
                System.out.println("on zero no delit"); - выведет эту строку
            } - и продолжит свою работу
    Пример обрабатывания исключений
    catch (ArithmeticException e) - указывается тип возможной ошибки и
    указывается рядом её произвольное название
    
           try{
                int b = 7 / a;
                String s = "sdhifdhid";
                int i = Integer.parseInt(s);
            }catch (ArithmeticException e){
                System.out.println("on zero no delit");
            } catch (NumberFormatException e1){
                System.out.println("Ошибка преобразования");
            }
    Можно сразу писать несколько catch для обрабатывания исключений раз-
    ошибок(например - сначала у нас идет обработка арифметических ошибок,
    затем ошибок преобразования)
    
    catch (Exception e){
                System.out.println("on zero no delit");
            } - обработает исключение любого вида
    Exception - родительское исключение от которого наследуются 
    другие исключения
    
    Если мы хотим отловить сначала исключение одного вида ,а потом
    уже все подряд ,то нужно написать - 
    }catch (ArithmeticException e){
                System.out.println("on zero no delit");
            }catch (Exception e1){ - при том ,Exception нужно будет всегда
    																 писать после ,определенного типа обработки
    																 исключений(иначе эта обработка обработает его
    																в самом начале не доходя до второй)
                System.out.println("error");
            }
    
    }catch (ArithmeticException e){
                System.out.println("on zero no delit");
            }catch (Exception e1){
    							e1.getMessage() - выдает суть ошибки
    							System.err.print() - аналогично
            }finally { - блок finally выполнится всегда(используется с 
    															потоками)
                System.out.println("мы в блоке finally");
            }
    ```
    
    //У всех исключений есть свои родительские исключения(у арифметических и т.д.)
    
    ## throw/throws
    
    ```java
    //1.Сначала обозначаем ошибку и выдаем её методе и т.д.
    Square(int side) throws Exception {
                    if (side <= 0) {
                        throw new Exception();
                    } else {
                        this.side = side;
                        System.out.println(side);
                    }
    //Square - в данном случае конструктор
    throw - выкидывает намеренно исключение при неверном значении
    throws - обозначает ,что в методе и т.д. будет выдаваться такое искл.
    
    //2.Затем обрабатываем её при вызове той или функции,объекта и т.д.
    //через try/catch - притом надо обработать то же исключение,что и 
    //в методе и т.д.
    try {
        Square sq = new Square(10);
    }catch (Exception e){
        System.out.println(e);
    }
    ```
    
    **Checked/Unchecked Execeptions** - **Checked** исключения это те исключения,которые мы сами обработали и предвидели
    
    **Unchecked** исключения это те исключения,которые мы ,собственно,не предвидели и они уже возникли во время работы
    
- **Методы String.format(),toString(), и случайные числа**
    
    //Все классы незаметно для нас наследуются от класса **Object**
    
    метод **toString** - переводит объект в строку
    
    ```java
    empty.toString();
    System.out.println(empty); - //test.empty@5b480cf9
    
    Методы от Object ,можно переопределить
    @Override
        public String toString() {
            return "Ширина: " + width + "\n Длина" + height;
        }
    
    System.out.println(empty.toString()); - выведет длину и ширину
    ```
    
    метод **String.format()** - принимает в себя строчку ,как параметр
    
    ```java
    @Override
        public String toString() {
            String res = String.format("Ширина %s \n Длина %s", width,length);
            return res;
        }
    
    **%s** - указывает место ,где подставится значение переменной
    **String.format()** - сначала идёт строка,а затем по порядку идут пере-
    менные со значениями,которые подставятся по порядку вместо **%s**
    
    ```
    
    метод **Math.*random*();** - возвращает число от 0 до 1(не включительно)
    
    ```java
    double random = Math.random();
    
    double random = Math.random();
    random *= 6; - улучшенный рандомайзер ))
    int randomInt = (int) random;
    System.out.println(randomInt);
    
    int res = (int) (Math.random() * 6 + 1); - краткий варик
    ```
    
- **Многопоточное программирование**
    
    Для того ,чтобы реализовать новый поток нужно написать классы **Thread** и реалтзовать интерфейс **Runnable** в каком-нибудь классе
    
    ```java
    **Thread** timer = new **Thread()**; - создание нового потока(правда он
    пока ничего не делает)
    
    (необязательно)Затем создаем класс,где реализуем интерфейс **Runnable -** 
    public class RunnableTimer implements Runnable{
        @Override
        public void run() { - этот метод сразу переопределяем
            for (int i = 0; i < 1000; i++){
                System.out.println(i);
            }
        }
    }
    
    метод **run()** - отвечает за ,то действие ,которое будет происходить
    в другом потоке
    
    Затем - 
    RunnableTimer runnableTimer = new RunnableTimer(); - создаём объект
     реализуемого интерфейса
    
    Thread timer = new Thread(runnableTimer); - передаем этот объект 
    как параметр
    
    **timer.start()**; - запускаем этот поток
    
    Потоки ,которые находятся в классе main называются главными потоками
    ,а остальные побочными
    
    Thread.sleep(1000); - делает паузу на столько-то милисекунд(нужно будет ловить
    исключение)
    Thread timer = new Thread(new Runnable() {
                @Override
                public void run() {
                    try{
                            for (int i = 0; i < 100000; i++) {
                                System.out.println(i);
                                Thread.sleep(1000);
                            }
                    }catch(Exception e){
                        System.out.println("error");
                    }
                }
            });
            timer.start(); - запуск побочного потока
    
    //Если в цикле что-то может вызвать искдючение 
    //,то лучше обработать его полностью
    
    ***//Чтобы работать с переменной в разных потоках 
    //нужно ее проинициализировать до точки входа(main)
    //и сделать эту переменную статичной***
    
    public class main {
    
        static boolean isFive = false;
    
        public static void main(String[] args) {
    
            Thread timer = new Thread(new Runnable() {
                @Override
                public void run() {
                    try{
                        int sec = 0;
                        while(true){
                            System.out.println(sec);
                            if (sec == 5){
                                isFive = true;
                            }
                            sec += 1;
                            Thread.sleep(1000);
                        }
                    }catch(Exception e){
                        System.out.println("error");
                    }
                }
            });
            timer.start();
            Thread timer2 = new Thread(new Runnable() {
                @Override
                public void run() {
                    try{
                        int sec = 0;
                        while(!isFive){
                            System.out.println(sec);
                            sec += 1;
                            Thread.sleep(1000);
                        }
                    }catch(Exception e){
                        System.out.println("error");
                    }
                }
            });
            timer2.start();
        }
    }
    
    ```
    
- **GIT**
    
    
- **Горячие клавиши**
    
    //psvm + tab - мы получим эту строчку public static  void  main(String...args)
    
    //sout + tab -  System.***out***.println()
    
    //Ctrl + Alt + l - форматирование
    
    //Alt + Ins - и потом выбираем contructor ,а затем его параметры и получаем готовый конструктор(также сойдёт и ддя других элементов)
    
    //Ctrl + P - помогает увидеть возможные параметры
    
    //Alt + enter - импортирует нужный класс при его отсутствии
    
    //Shift + F6 - позволяет сразу переменновать переменную в нескольких местах
    
    //Ctrl + i - переопределение метода у доч.классов
    
    //Ctrl + O - переопределяет метод
    
    //Ctrl + alt + t  - быстрая обертка в if/else ,try/catch и т.д.
    
- **Работа с консолью**
    
    ```java
    javac -version ---- проверка версии **jdk**
    javac имяФайла.java --- запуск программы(компиляция) 
    java названиеКласса --- запуск класса(программа автоматически его находит)
    java -classpath classes_dir имяФайла --- запуск класса, при условии ,что он находится 
    в другой папке
    (если программа состоит из нескольких исход файлов перечисляем их через пробел)
    javap -v имяФайла.java --- вывод байт кода откомпилированного файла вместе с инструкциями 
             
    ```
    
- **Дополнительно**
    
    

# Часть 2

- **Тесты.JUnit(Gradle немного).@BeforeAll,@AfterAll**
    
    **JUnit** - библиотека для автоматического тестирования
    
    Для того ,чтобы добавить эту библиотеку ,нужно завести зависимости,а для этого нужны сборщики проектов ,как **Gradle** и **Maven**
    
                         Создание проекта **Gradle(intellij idea)**
    
                *File - new project - и выбираем gradle и т.д.*
    
    *,а в остальных средах нужно написать в терминал* 
    
                                          **gradle init**
    
    При сборке мы получаем файл **build.gradle** (ключевой файл)
    
    В нем как раз мы и сможем хранить разные библиотеки и плагины(зависимости)
    
    Также мы получим модули **main** и **test**
    
    *В **main** будут храниться классы с каким-либо действием*
    
    В  **test** *будут храниться классы с тестами нашего кода*
    
    ### Создание теста
    
    **В intellij idea**  - нажимаем на имя класса,затем Alt + enter - создать тест(а затем выбираем метод,который будем тестировать)
    
    Если не в **Intellij idea** ,то захом в папку **test - java** создаем класс ,тестирующий что-либо.Затем переопределяем тестируемый метод с аннотацией **Test**
    
    ```java
    		@Test
        public void add(){
    			///
        }
    В тесте должны быть две переменных
    Одна должна хранить в себе ожидаемое значение,
    а другая реальное значение
    
    ----------------
    @Test
        public void add(){
            Calculator ncalc = new Calculator();
            int sum = 15; - ожидаемое значение
            int res =  ncalc.add(10,5); - реальное значение
            assertEquals(sum,res);
        }
    ```
    
    ***assertEquals(sum,res)***; - метод из библиотеки **JUNIT** ,нужен для сравнения ***ожидаемого значения с реальным*** ,также в качестве 3-го параметра  может принимать погрешность*(нужно для сравнивания дробных чисел)*
    
    ***assertEquals*(sum,res, 0.001);**
    
    Для тестирования приходится создать объект какого-либо тестируемого класса.И чтобы в каждом тесте его не создавать гужно использовать аннотацию **@BeforeAll**
    
    ```java
    private Calculator calc; - создаём используемую 
    переменную  
    
    	 @BeforeAll - указываем аннотацию,которая указывает постоянное 
    значение этой переменной
        public void setup(){
                calc = new Calculator(); - задаём значение
        }
    
    -----------
    @Test
        public void add(){
    			......
            double actual1 = calc.add(30,5.15);
            assertEquals(expected1,actual1,0.001);
        }
    Будет достаточно написать просто 
    название переменной-объекта(в данном случае) и 
    вызвать метод этого объекта,а не постоянно его создавать
    
        @Test
        public void sub(){
    			..,...
            double actual1 = calc.sub(38.9,4.9);
            assertEquals(expected1,actual1,0.001);
        }
    
    То есть аннотация **@BeforeAll** позволяет один раз
    в самом начале указать значение переменной ,
    а дальше просто её использовать в тестах
    ```
    
    **@AfterAll** - это аннотация ,которая вызывет метод после тестирования
    
    ```java
    @AfterAll
        public void end(){
            System.out.println("end testing");
        }
    
    вызовется после тестирования
    ```
    
    Если мы пытаемя проверить получаемое значение от какого-либо метода , то лучше в самом названии теста писать ,что мы проверяем**(whenAddTenToFiveResultFifeteen)** -типо этого.То есть не стоит в один тест сразу несколько проверок пихать
    
    пересмотреть конец этого видео