# Справочник по C#

- Терминология
    
    **Кодовый файл** — это один из файлов на языке C#.
    
    **Проект** — это совокупность кодовых файлов, которые могут быть скомпилированы в сборку: программу или библиотеку.
    
    **Сборка** — это, соответственно, результат компиляции проекта. Как правило это ***.exe** или ***.dll** файл, содержащий инструкции для компьютера.
    
    **Решение (solution)** — это несколько проектов, объединенные общими библиотеками и задачами. Как правило открывать с помощью Visual Studio нужно именно файл решения **(*.sln)**, хотя можно открыть и отдельный проект **(*.csproj файл)**. Имейте в виду, если открыть отдельный кодовый файл, не открывая проект или решение, то не будет возможности его запустить. Это распространённая ошибка новичков.
    
    **Reference** — ссылка внутри проекта на другие сборки. Только сославшись на другую сборку можно будет использовать код из неё.
    
    **Метод** — это последовательность действий. Аналог функций, процедур и подпрограмм в других языках. В устной речи часто используют все эти слова как синонимы, но в спецификации на язык C# используется термин «метод».
    
    **Класс** — это совокупность данных и методов. Все сборки состоят из скомпилированных классов.
    
    **Пространство имен** — это совокупность классов, логически связанных между собой.
    
    Между сборками и пространствами имен нет прямого соответствия: в сборке может хранится несколько пространств имен, а разные классы одного пространства имен могут быть определены в разных сборках.
    
    После успешной компиляции, в директории проекта создается поддиректория bin/Debug, в которой и оказывается сборка — результат компиляции — **exe** или **dll** файлы вашей программы.
    
    ```csharp
    // Таким образом вы подключаете пространство имен System к вашему кодовому файлу 
    // (не к всему проекту! Это не Reference!)
    using System;
    
    //Таким образом вы определяете свое пространство имен.
    namespace Lectures
    {
    	// Таким образом определяется класс.
    	class Program
    	{
    		/*
    		 * static - некое волшебное слово, смысл которого будет ясен позднее.
    		 * void Main() определяет метод.
    		 * Из-за своего названия Main является точкой входа — это метод, 
    		 * который будет запущен при выполнении программы.
    		 */
    		static void Main()
    		{
    			// Этот код выводит на экран строку
    			// Console — это класс, так же как Program, но из пространства имен System.
    			Console.WriteLine("Hello, world!");
                // Обратите внимание, регистр символов имеет значение!
                // Console.writeline("Hello, world"); // это не скомпилируется.
    			
    			// Как и в любом языке программирования, нужно строго соблюдать синтаксис.
    			// Например, каждую инструкцию нужно заканчивать точкой с запятой.
    			// Сonsole.WriteLine("Hello, world") // это не скомпилируется.
    
    			// Попробуйте совершить несколько ошибок и посмотреть на сообщения об ошибках
            }
        }
    }
    ```
    
- ***Основные концепции.**Что из себя представляет **.NET***
    
    ***.NET*** - это платформа программирования под **windows**
    
    ***.NET Core*** - открытый **кросс-платформенный** фреймворк,продолжение ***.NET***
    
    ***C#*** - основной язык программирования ,использующийся в этих платформах
    
    *//Различия в основном в платформах и технологиях ,которые они используют*
    
    ## Из чего состоят ***.NET & .NET Core***
    
    - Исполняющей среды **(CLR - Common Language Runtime или Core CLR)**
    
    //Разница между **CLR** и **Core CLR** в том ,что  **CLR** используется в ***.NET Framework***,а **Core CLR** используется в  ***.NET Core***
    
    - Базовых библиотек классов **BCL(Base Class Library)**  =  **FCL(Foundation Class Library) + Frameworks**
    
    **FCL** - это фундаментальный набор библиотек,который позволяет писать код ,обращающийся к сокетамя,файлам и т.д.
    
    **Frameworks** - это наборы классов,решающие определенные задачи**(WPF,ASP.NET и т.д.)**
    
    ## Как работает код на C#?
    
    **Компилятор** - компонент ,совершающий **компиляцию**,называется компилятор
    
    **Компиляция** - это перевод  высокоуровнего кода в машинный
    
    **//**Компилятор(-ная- платформа) в **C#** называется **Roslyn**
    
    В  **C#** сначала высокоуровневый код переводится в **ByteCode = CIL code(Common Intermidiate Language)** = **IL**(не совсем машинный код,но и не совсем высокоуровневый код )
    
    **//**Затем ,когда мы запускаем код на **C#** , в памяти откладывается **CLR** или **CORE CLR**
    
    (которая выполняет очистку мусора,переводит **ByteCode** в машинный код**(Native Code)**(это называется **JIT- just in time**)
    
    Всё ,что происходит с кодом до запуска программы называется **Compile time** ,а после запуска **Run time**(время выполнения)
    
- Из чего состоит приложение **.NET?**
    
    Любое приложение на **C#** состоит из классов
    
    **Классы** - это модуль,который данные и методы ,объеденненые разной логикой.
    
    **//**У каждого класса **есть своё название**,**но можно в программе иметь несколько классов с одинаковым названием** ,а чтобы компилятор их различил **,надо объединять их в пространство имен**,которые содержат в себе классы схожие по логике.
    
    **//**То есть класс **car** может быть и в пространстве имён ,как **Manufacturing** ,так и в **Management**(например)
    
    **//**И у каждого класса есть **придворённое имя**,в которое входит **пространство имён**
    
    Например:
    
    классы **car** ,входящие в пространство имён ,как **Manufacturing** ,так и в **Management -** 
    
    будут называться вот так - **Manufacturing.car и Management.car**
    
    **//**Также пространство **имён может хранить в себе подпространство имён(БУМ!)**
    
    **//**Объявлять классы вне пространств имён можно , **но** на практике не используется
    
    — А это всё входит в сборку**(Assembly)** *,которая хранит в себе пространство имен и по сути является физической единицей в программе* —
    
    — Сборки в свою очередь бывают двух типов - библиотек **DLL** и запускаемыми приложениями **EXE —** 
    
- Структура программы
    
    ### Инструкции
    
    Базовым строительным блоком программы являются **инструкции** (statement). Инструкция представляет некоторое действие, например, арифметическую операцию, вызов метода, объявление переменной и присвоение ей значения. В конце каждой инструкции в **C#** ставится точка с запятой **(;)**. Данный знак указывает компилятору на конец инструкции. Например, в проекте консольного приложения, который создается по умолчанию, есть такая строка:
    
    ```csharp
    Console.WriteLine("Hello, World!");
    ```
    
    Данная строка представляет вызов метода `Console.WriteLine`, который выводит на консоль строку. В данном случае вызов метода является инструкцией и поэтому завершается точкой с запятой.
    
    Набор инструкций может объединяться в ***блок кода***. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками. Например, изменим код файла **Program.cs** на следующий:
    
    ```csharp
    {
        Console.WriteLine("Привет");
        Console.WriteLine("Добро пожаловать в C#");
    }
    ```
    
    //Одни блоки кода могут содержать другие блоки
    
    ### **Регистрозависимость**
    
    -это значит, что в зависимости от регистра символов какие-то определенные названия могут представлять разные классы, методы, переменные и т.д
    
    ### **Комментарии(способы)**
    
    ```csharp
    /*
           первая программа на C#,
           которая выводит приветствие на консоль
    */
    
    // Выводим строку "Привет"
    ```
    
    ### Файл проекта
    
    В каждом проекте проекте **C#** есть файл, который отвечает за общую конфгурацию проекта. По умолчанию этот файл называется ***Название_проекта.csproj**.* Итак, откроем данный файл. Для этого либо двойным кликом левой кнопкой мыши нажмем на название проекта, либо нажмем на название проекта правой кнопкой мыши и в появившемся меню выберем пункт ***Edit Project File***
    
    Этот файл в виде кода xml определяет конфгурацию проекта и он может содержать множество элементов. Остановлюсь только на двух основных:
    
    - **OutputType**: определяет выходной тип проекта. Это может быть выполняемое приложение в виде файла с расширением **exe**, которое запускается по нажатию. И также это может быть файл с расширением **.dll** - некоторый набор функциональностей, который используется другими проектами. По умолчанию здесь установлено значение "Exe", что значит, что мы создаем исполняемое приложение.
    - **TargetFramework**: определяет применяемую для компиляции версию фреймворка .NET. В данном случае это значение "net6.0", то есть применяется .NET 6.0.
- Переменные
    
    Для хранения данных в программе применяются **переменные**. Переменная представляет именнованную область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная.
    
    ```csharp
    тип имя_переменной;
    string name;
    string Name; -Разные переменные
    //string name = "Tom";
    ```
    
    Вначале идет тип переменной, потом ее имя. В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:
    
    - имя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания
    - в имени не должно быть знаков пунктуации и пробелов
    - имя не может быть ключевым словом языка **C#**. Таких слов не так много, и при работе в **Visual Studio** среда разработки подсвечивает ключевые слова синим цветом.
    
    Хотя имя переменой может быть любым, но следует давать переменным описательные имена, которые будут говорить об их предназначении.
    
    Константы предназначены для описания таких значений, которые не должны изменяться в программе. Для определения констант используется ключевое слово **const**, которое указывается перед типом константы:
    
    ```csharp
    
    const string NAME = "Tom";
    const string NAME;  // ! Ошибка - константа NAME не инициализирована
    ```
    
- Литералы
    
    Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово `null`.
    
    ### **Логические литералы**
    
    Есть две логических константы - **true** (истина) и **false** (ложь):
    
    ```csharp
    Console.WriteLine(true);
    Console.WriteLine(false);
    ```
    
    ### **Целочисленные литералы**
    
    Целочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. Целочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.
    
    С целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:
    
    ```csharp
    Console.WriteLine(-11);
    Console.WriteLine(5);
    Console.WriteLine(505);
    ```
    
    Числа в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:
    
    ```csharp
    Console.WriteLine(0b11);        // 3
    Console.WriteLine(0b1011);      // 11
    Console.WriteLine(0b100001);    // 33
    
    ----------------------------------------
    Для записи числа в шестнадцатеричной форме применяются символы 0x, 
    после которых идет набор символов от 0 до 9 и от A до F, которые собственно 
    представляют число:
    
    Console.WriteLine(0x0A);    // 10
    Console.WriteLine(0xFF);    // 255
    Console.WriteLine(0xA1);    // 161
    ```
    
    ### **Вещественные л**итералы
    
    Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например:
    
    ```csharp
    3.14
    100.001
    -0.38
    
    -----------------------------------------------------
    Также вещественные литералы могут определяться в экспоненциальной форме MEp, 
    где M — мантисса, E - экспонента, которая фактически означает "*10^" 
    (умножить на десять в степени), а p — порядок. Например:
    
    Console.WriteLine(3.2e3);   // по сути равно 3.2 * 10<sup>3</sup> = 3200
    Console.WriteLine(1.2E-1);  // равно 1.2 * 10<sup>-1</sup> = 0.12
    ```
    
    ### **Символьные литералы**
    
    Символьные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки.
    
    Символьные литералы бывают нескольких видов. Прежде всего это обычные символы:
    
    ```csharp
    '2'
    'A'
    'T'
    ```
    
    Специальную группу представляют ***управляющие последовательности*** .Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:
    
    - `'\n'` - перевос строки
    - `'\t'` - табуляция
    - `'\\'` - слеш
    
    Определить символы можно ,также через коды **ASCII** и **Unicode:**
    
    ```csharp
    Для этого в одинарных кавычках указываются символы '\x', после которых 
    идет шестнадцатеричный код символа из таблицы ASCII:
    
    Console.WriteLine('\x78');    // x
    Console.WriteLine('\x5A');    // Z
    -------------------------------------------------
    Для этого в одинарных кавычках указываются символы '\u', после которых идет
    шестнадцатеричный код Unicode:
    Console.WriteLine('\u0420');    // Р
    Console.WriteLine('\u0421');    // С
    ```
    
    ### **Строковые литералы**
    
    Строковые литералы представляют строки. Строки заключаются в двойные кавычки:
    
    ```csharp
    Console.WriteLine("hello");
    Console.WriteLine("фыва");
    Console.WriteLine("hello word");
    -----------------------------------------------
    Console.WriteLine("Компания \"Рога и копыта\"");
    Console.WriteLine("Привет \nмир");
    ```
    
    ***Null*** - представляет ссылку, которая не указывает ни на какой объект. То есть по сути отсутствие значения.
    
- Типы данных.Неявная типизация
    
    Как и во многих языках программирования, в C# есть своя система типов данных, которая используется для создания переменных. Тип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.
    
    В языке C# есть следующие базовые типы данных:
    
    - **bool**: хранит значение `true` или `false` (логические литералы). Представлен системным типом `System.Boolean`
        
        ```csharp
        bool alive = true;
        bool isDead = false;
        ```
        
    - **byte**: хранит целое число от `0` до `255` и занимает 1 байт. Представлен системным типом `System.Byte`
        
        ```csharp
        byte bit1 = 1;
        byte bit2 = 102;
        ```
        
    - **sbyte**: хранит целое число от -`128` до `127` и занимает 1 байт. Представлен системным типом `System.SByte`
        
        ```csharp
        sbyte bit1 = -101;
        sbyte bit2 = 102;
        ```
        
    - **short**: хранит целое число от -`32768` до `32767` и занимает 2 байта. Представлен системным типом `System.Int16`
        
        ```csharp
        short n1 = 1;
        short n2 = 102;
        ```
        
    - **ushort**: хранит целое число от `0` до `65535` и занимает 2 байта. Представлен системным типом `System.UInt16`
        
        ```csharp
        ushort n1 = 1;
        ushort n2 = 102;
        ```
        
    - **int**: хранит целое число от -`2147483648` до `2147483647` и занимает 4 байта. Представлен системным типом `System.Int32`. Все целочисленные литералы по умолчанию представляют значения типа int:
        
        ```csharp
        int a = 10;
        int b = 0b101;  // бинарная форма b =5
        int c = 0xFF;   // шестнадцатеричная форма c = 255
        ```
        
    - **uint**: хранит целое число от `0` до `4294967295` и занимает 4 байта. Представлен системным типом `System.UInt32`
        
        ```csharp
        uint a = 10;
        uint b = 0b101;
        uint c = 0xFF;
        ```
        
    - **long**: хранит целое число от `–9 223 372 036 854 775 808` до `9 223 372 036 854 775 807` и занимает 8 байт. Представлен системным типом `System.Int64`
        
        ```csharp
        long a = -10;
        long b = 0b101;
        long c = 0xFF;
        ```
        
    - **ulong**: хранит целое число от `0` до `18 446 744 073 709 551 615` и занимает 8 байт. Представлен системным типом `System.UInt64`
        
        ```csharp
        ulong a = 10;
        ulong b = 0b101;
        ulong c = 0xFF;
        ```
        
    - **float**: хранит число с плавающей точкой от `3.4*1038` до `3.4*1038` и занимает 4 байта. Представлен системным типом `System.Single`
    - **double**: хранит число с плавающей точкой от `±5.0*10324` до `±1.7*10308` и занимает 8 байта. Представлен системным типом `System.Double`
    - **decimal**: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*1028 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом `System.Decimal`
    - **char**: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом `System.Char`. Этому типу соответствуют символьные литералы:
        
        ```csharp
        char a = 'A';
        char b = '\x5A';
        char c = '\u0420';
        ```
        
    - **string**: хранит набор символов Unicode. Представлен системным типом `System.String`. Этому типу соответствуют строковые литералы.
        
        ```csharp
        string hello = "Hello";
        string word = "world";
        ```
        
    - **object**: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом `System.Object`, который является базовым для всех других типов и классов .NET.
        
        ```csharp
        object a = 22;
        object b = 3.14;
        object c = "hello code";
        ```
        
        ### **Использование суффиксов**
        
        При присвоении значений надо иметь в виду следующую тонкость: все вещественные литералы (дробные числа) рассматриваются как значения типа **double**. И чтобы указать, что дробное число представляет тип **float** или тип **decimal**, необходимо к литералу добавлять суффикс: F/f - для float и M/m - для decimal.
        
        ```csharp
        float a = 3.14F;
        float b = 30.6f;
         
        decimal c = 1005.8M;
        decimal d = 334.8m;
        ```
        
        Подобным образом все целочисленные литералы рассматриваются как значения типа **int**. Чтобы явным образом указать, что целочисленный литерал представляет значение типа uint, надо использовать суффикс **U/u**, для типа **long** - суффикс **L/l**, а для типа **ulong** - суффикс **UL/ul**:
        
        ```csharp
        uint a = 10U;
        long b = 20L;
        ulong c = 30UL;
        ```
        
        ### **Использование системных типов**
        
        Выше при перечислении всех базовых типов данных для каждого упоминался системный тип. Потому что название встроенного типа по сути представляет собой сокращенное обозначение системного типа. Например, следующие переменные будут эквивалентны по типу:
        
        ```csharp
        int a = 4;
        System.Int32 b = 4;
        ```
        
        ### Неявная типизация
        
        Ранее мы явным образом указывали тип переменных, например, `int x;`. И компилятор при запуске уже знал, что x хранит целочисленное значение.
        
        Однако мы можем использовать и модель неявной типизации:
        
        ```csharp
        var hello = "Hell to World";
        var c = 20;
        ```
        
        Для неявной типизации вместо названия типа данных используется ключевое слово `var`. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения. Так как по умолчанию все целочисленные значения рассматриваются как значения типа `int`, то поэтому в итоге переменная c будет иметь тип `int`. Аналогично переменной `hello` присваивается строка, поэтому эта переменная будет иметь тип `string`
        
        Эти переменные подобны обычным, однако они имеют некоторые ограничения.
        
        Во-первых, мы не можем сначала объявить неявно типизируемую переменную, а затем инициализировать:
        
        ```csharp
        // этот код работает
        int a;
        a = 20;
         
        // этот код не работает
        var c;
        c= 20;
        
        // этот код не работает
        var c=null;
        ```
        
- Основные типы данных**(C# types and BCL types)(Дополнительно)**
    
    # Примитивные типы данных
    
    ### Целые числа
    
    **byte** - **int** на минималках**(1 bytes)** хранит в себе значения от 0 до 255**(BCL TYPE - System.Byte)**
    
    **sbyte** - хранит в себе значения от -128 до 127**(BCL TYPE - System.SByte)**
    
    **short** - кароткий **int (2 bytes)** хранит в себе значения от -32.768 до 32.767**(BCL TYPE - System.Int16)**
    
    **ushort** - хранит в себе значения от 0 до 65.535**(BCL TYPE - System.UInt16)**
    
    **int** - целое число**(4 bytes)**  хранит в себе значения от -2.147.483.648 до 2.147.483.647**(BCL TYPE - System.Int32)**
    
    **uint** - хранит в себе значения от 0 до 4.294.967.295**(BCL TYPE - System.UInt32)**
    
    **long** - длинный **int (8 bytes)** хранит в себе значения от -9.223.372.036.854.775.808 до 9.223.372.036.854.775.807**(BCL TYPE - System.Int64)**
    
    **ulong** - хранит в себе значения от 0 до 18.446.744.073.709.551**(BCL TYPE - System.UInt64)**
    
    ### Числа с плавающей точкой
    
    **double** - число с плавающей точкой**(десятичное число)8 bytes)** хранит в себе значения от **10 в -324 ст до 10 в 308 ст(BCL TYPE - System.Double)**
    
    **float** - кароткий **double (десятичное число)4 bytes)** хранит в себе значения от 3,4 **в -38 ст до 3,4 в 38 ст(BCL TYPE - System.Single)**
    
    ### Символы и Строки
    
    **char** - символ из какого-либо алфавита **(’G’,’F’)2 bytes) (BCL TYPE - System.Char)**
    
    **string** - хранит в себе строку,которая состоит из **N кол-ва char-ов(’Hello World’)N bytes)(BCL TYPE - System.String)**
    
    ### Логический тип данных
    
    **bool** - хранит в себе **True/False** **(1 bytes)(BCL TYPE - System.Boolean)**
    
    # Сложные типы данных
    
    **decimal** - число с плавающей точкой(типа **long** только с плавающей точкой) **16 bytes) х**ранит в себе значения от много до очень много+29 чисел после запятой точность епт**(BCL TYPE - System.Decimal)**
    
    **DateTime** - хранит в себе время,дату**(8 bytes)** **(BCL TYPE - System.DateTime)**
    
    **TimeSpan** - продолжительность времени**(8 bytes)(BCL TYPE - System.SpanTime)**
    
    **Guid** - уникальный индентификатор**(16 bytes)(BCL TYPE - System.Guid)**
    
    **Object** - объект,может в себе содержать любой тип данных**(16 bytes)(BCL TYPE - System.Object)**
    
    **BigInteger** - гигантский long
    
    **Complex** - комплексные числа
    
    **// Разницы между** **C# types and BCL types нету,** **C# types - это кароткий псевдоним BCL types**
    
- Ввод-Вывод
    
    ### **Консольный вывод**
    
    **Console.WriteLine**
    
    ```csharp
    
    string hello = "Привет мир";
    Console.WriteLine(hello);
    
    string name = "Tom";
    int age = 34;
    double height = 1.7;
    Console.WriteLine($"Имя: {name}  Возраст: {age}  Рост: {height}м");
    //$" {name}" - интерполяция
    -----------------------------------------
    Console.WriteLine("Имя: {0}  Возраст: {2}  Рост: {1}м", name, height, age);  - 
    аналог вывода
    ```
    
    **метод Console.Write()** - он работает точно так же за тем исключением, 
    что не добавляет переход на следующую строку, то есть последующий консольный вывод 
    будет выводиться на той же строке :
    
    ```csharp
    string name = "Tom";
    int age = 34;
    double height = 1.7;
    Console.Write($"Имя: {name}  Возраст: {age}  Рост: {height}м");
    //Имя: Tom  Возраст: 34  Рост: 1,7м
    ```
    
    ### Консольный ввод
    
    **Console.ReadLine()** - позволяет получить введенную строку
    
    ```csharp
    Console.Write("Введите свое имя: ");
    string? name = Console.ReadLine();
    Console.WriteLine($"Привет {name}");
    
    //? - указывает, что переменная также может хранить значение null, 
    //то есть по сути не иметь никакого значения
    ```
    
    #Особенностью метода `Console.ReadLine()` является то, что он может считать информацию с консоли только в виде строки.
    
    ### Перевод из одного типа данных в другой
    
    - **Convert.ToInt32()** (преобразует к типу **int**)
    - **Convert.ToDouble()** (преобразует к типу **double**)
    - **Convert.ToDecimal()** (преобразует к типу **decimal**)
    
    ```csharp
    Console.Write("Введите имя: ");
    string? name = Console.ReadLine();
     
    Console.Write("Введите возраст: ");
    int age = Convert.ToInt32(Console.ReadLine());
     
    Console.Write("Введите рост: ");
    double height = Convert.ToDouble(Console.ReadLine());
     
    Console.Write("Введите размер зарплаты: ");
    decimal salary = Convert.ToDecimal(Console.ReadLine());
     
    Console.WriteLine($"Имя: {name}  Возраст: {age}  Рост: {height}м  Зарплата: {salary}$");
    ```
    
    *#При вводе важно учитывать текущую операционную систему. В одних культурах разделителем между целой и дробной частью является точка **(США, Великобритания...), в других - запятая (Россия, Германия...)**. Например, если текущая **ОС** - русскоязычная, значит, надо вводить дробные числа с разделителем запятой. Если локализация англоязычная, значит, разделителем целой и дробной части при вводе будет точка.*
    
- Арифметические операции языка C#
    
    В качестве операнда может выступать переменной или какое-либо значение (например, число). Операции бывают **унарными** (выполняются над одним операндом), **бинарными** - над двумя **операндами** и **тернарными** - выполняются над тремя **операндами.**
    
    **Бинарные** арифметические операции:
    
    ```csharp
    + - сложение
    
    int x = 10;
    int z = x + 12; // 22
    ------------------------------
    - - вычитание
    
    int x = 10;
    int z = x - 6; // 4
    ------------------------------
    * - умножение
    
    int x = 10;
    int z = x * 5; // 50
    ------------------------------
    / - деление(так и целочисленное деление)
    
    int x = 10;
    int z = x / 5; // 2
     
    double a = 10;
    double b = 3;
    double c = a / b; // 3.33333333
    
    ------------------------------
    % - операция получение остатка от целочисленного деления двух чисел
    
    double x = 10.0;
    double z = x % 4.0; //результат равен 2
    ```
    
    Также есть ряд унарных операций, в которых принимает участие один операнд:
    
    - **++**
        
        Операция инкремента
        
        Инкремент бывает префиксным: `++x` - сначала значение переменной x увеличивается на 1, а потом ее значение возвращается в качестве результата операции.
        
        И также существует постфиксный инкремент: `x++` - сначала значение переменной x возвращается в качестве результата операции, а затем к нему прибавляется 1.
        
        ```csharp
        int x1 = 5;
        int z1 = ++x1; // z1=6; x1=6
        Console.WriteLine($"{x1} - {z1}");
         
        int x2 = 5;
        int z2 = x2++; // z2=5; x2=6
        Console.WriteLine($"{x2} - {z2}");
        ```
        
    - - -
    
    Операция декремента или уменьшения значения на единицу. Также существует префиксная форма декремента (`--x`) и постфиксная (`x--`).
    
    ```csharp
    int x1 = 5;
    int z1 = --x1; // z1=4; x1=4
    Console.WriteLine($"{x1} - {z1}");
     
    int x2 = 5;
    int z2 = x2--; // z2=5; x2=4
    Console.WriteLine($"{x2} - {z2}");
    ```
    
    При выполнении сразу нескольких арифметических операций следует учитывать порядок их выполнения. Приоритет операций от наивысшего к низшему:
    
    1. Инкремент, декремент
    2. Умножение, деление, получение остатка
    3. Сложение, вычитание
    
    Для изменения порядка следования операций применяются скобки.
    
    ### Ассоциативность операторов
    
    Как выше было отмечено, операции умножения и деления имеют один и тот же приоритет, но какой тогда результат будет в выражении:
    
    ```csharp
    int x = 10 / 5 * 2;
    ```
    
    Стоит нам трактовать это выражение как `(10 / 5) * 2` или как `10 / (5 * 2)`? Ведь в зависимости от трактовки мы получим разные результаты.
    
    Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности есть два типа операторов:
    
    - Левоассоциативные операторы, которые выполняются слева направо
    - Правоассоциативные операторы, которые выполняются справа налево
    
    Все арифметические операторы являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение `10 / 5 * 2` необходимо трактовать как `(10 / 5) * 2`, то есть результатом будет 4.
    
- Поразрядные операции
    
    ### Логические операции
    
    - **&**(логическое умножение)
        
        Умножение производится поразрядно, и если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0. Например:
        
        ```csharp
        int x1 = 2; //010
         int y1 = 5;//101
         Console.WriteLine(x1&y1); // выведет 0
                     
        int x2 = 4; //100
        int y2 = 5; //101
        Console.WriteLine(x2 & y2); // выведет 4
        ```
        
        В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число 010, а 5 - 101. Поразрядно умножим числа (0*1, 1*0, 0*1) и в итоге получим 000.
        
        Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, так же как и у числа 5, поэтому в итоге получим (1*1, 0*0, 0 *1) = 100, то есть число 4 в десятичном формате.
        
    - **|** (логическое сложение)
        
        Похоже на логическое умножение, операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица. Например:
        
        ```csharp
        int x1 = 2; //010
        int y1 = 5;//101
        Console.WriteLine(x1|y1); // выведет 7 - 111
        int x2 = 4; //100
        int y2 = 5;//101
        Console.WriteLine(x2 | y2); // выведет 5 - 101
        ```
        
    - **^** (логическое исключающее ИЛИ)
        
        Также эту операцию называют XOR, нередко ее применяют для простого шифрования:
        
        ```csharp
        int x = 45; // Значение, которое надо зашифровать - в двоичной форме 101101
        int key = 102; //Пусть это будет ключ - в двоичной форме 1100110
         
        int encrypt = x ^ key; //Результатом будет число 1001011 или 75
        Console.WriteLine($"Зашифрованное число: {encrypt}") ;
         
        int decrypt = encrypt ^ key; // Результатом будет исходное число 45
        Console.WriteLine($"Расшифрованное число: {decrypt}");
        ```
        
    - **~** (логическое отрицание или инверсия)
        
        Еще одна поразрядная операция, которая инвертирует все разряды: если значение разряда равно 1, то оно становится равным нулю, и наоборот.
        
        ```csharp
        int x = 12;                 // 00001100
        Console.WriteLine(~x);      // 11110011   или -13
        ```
        
    
    ### Представление отрицательных чисел
    
    Для записи чисел со знаком в C# применяется **дополнительный код** (two’s complement), при котором старший разряд является знаковым. Если его значение равно 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. Например, 0000 0001 в десятичной системе 1.
    
    Если старший разряд равен 1, то мы имеем дело с отрицательным числом. Например, 1111 1111 в десятичной системе представляет -1. Соответственно, 1111 0011 представляет -13.
    
    Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу:
    
    ```csharp
    int x = 12;
    int y = ~x;
    y += 1;
    Console.WriteLine(y);   // -12
    ```
    
    ### Операции сдвига
    
    Операции сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.
    
    - `x<<y` - сдвигает число x влево на y разрядов. Например, `4<<1` сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, то есть в итоге получается 1000 или число 8 в десятичном представлении.
    - `x>>y` - сдвигает число x вправо на y разрядов. Например, `16>>1` сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.
    
    Таким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два. Поэтому подобную операцию можно использовать вместо непосредственного умножения или деления на два. Например:
    
    ```csharp
    int a = 16; // в двоичной форме 10000
    int b = 2; // в двоичной форме
    int c = a << b; // Сдвиг числа 10000 влево на 2 разряда, равно 1000000 или 64 в десятичной системе
     
    Console.WriteLine($"Зашифрованное число: {c}") ;    // 64
     
    int d = a >> b; // Сдвиг числа 10000 вправо на 2 разряда, равно 100 или 4 в десятичной системе
    Console.WriteLine($"Зашифрованное число: {d}");     // 4
    ```
    
    ```csharp
    int a = 22; // в двоичной форме 10110
    int b = 2; // в двоичной форме
    int c = a << b; // Сдвиг числа 10110 влево на 2 разряда, равно 1011000 или 88 в десятичной системе
     
    Console.WriteLine($"Зашифрованное число: {c}") ;    // 88
     
    int d = a >> b; // Сдвиг числа 10110 вправо на 2 разряда, равно 101 или 5 в десятичной системе
    Console.WriteLine($"Зашифрованное число: {d}");     // 5
    ```
    
- Операции присваивания
    
    Операции присвоения устанавливают значение. В операциях присвоения участвуют два операнда, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную
    
    Как и во многих других языках программирования, в C# имеется базовая операция присваивания **=**, которая присвоивает значение правого операнда левому операнду:
    
    ```csharp
    int number = 23;
    -----------------------
    Множественное присваивание
    
    int a, b, c;
    a = b = c = 34;
    -----------------------
    Тоже множественное присваивание
    *Сначала будет вычисляться выражение 34 * 2 / 4, затем полученное значение 
    будет присвоено переменным.*
    
    int a, b, c;
    a = b = c = 34 * 2 / 4; // 17
    ```
    
    Кроме базовой операции присвоения в C# есть еще ряд операций:
    
    - **+=**: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: выражение **A += B** равнозначно выражению **A = A + B**
    - **=**: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: **A -= B** эквивалентно **A = A - B**
    - **=**: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: **A *= B** эквивалентно **A = A * B**
    - **/=**: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: **A /= B** эквивалентно **A = A / B**
    - **%=**: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: **A %= B** эквивалентно **A = A % B**
    - **&=**: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: **A &= B** эквивалентно **A = A & B**
    - **|=**: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: **A |= B** эквивалентно **A = A | B**
    - **^=**: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: **A ^= B** эквивалентно **A = A ^ B**
    - **<<=**: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: **A <<= B** эквивалентно **A = A << B**
    - **>>=**: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: **A >>= B** эквивалентно **A = A >> B**
    
    ```csharp
    int a = 10;
    a += 10;        // 20
    a -= 4;         // 16
    a *= 2;         // 32
    a /= 8;         // 4
    a <<= 4;      // 64
    a >>= 2;      // 16
    ```
    
    Операции присвоения являются правоассоциативными, то есть выполняются справа налево. Например:
    
    ```csharp
    int a = 8;
    int b = 6;
    int c = a += b -= 5;    // 9
    //то есть сначала b - 5 ,затем a + b(1)
    ```
    
- Преобразования базовых типов данных
    
    ### Сужающие и расширяющие преобразования
    
    Преобразования могут быть сужающие (narrowing) и расширяющие (widening). Расширяющие преобразования расширяют размер объекта в памяти. Например:
    
    ```csharp
    byte a = 4;             // 0000100
    ushort b = a;   // 000000000000100
    ```
    
    В данном случае переменной типа ushort присваивается значение типа byte. Тип byte занимает 1 байт (8 бит), и значение переменной a в двоичном виде можно представить как:
    
    ```csharp
    00000100
    ```
    
    Значение типа ushort занимает 2 байта (16 бит). И при присвоении переменной b значение переменной a расширяется до 2 байт
    
    ```csharp
    0000000000000100
    ```
    
    То есть значение, которое занимает 8 бит, **расширяется** до 16 бит.
    
    Сужающие преобразования, наоборот, сужают значение до типа меньшей разядности. Во втором листинге статьи мы как раз имели дело с сужающими преобразованиями:
    
    ```csharp
    ushort a = 4;
    byte b = (byte) a;
    ```
    
    Здесь переменной **b**, которая занимает 8 бит, присваивается значение **ushort**, которое занимает 16 бит. То есть из `0000000000000100` получаем `00000100`. Таким образом, значение сужается с 16 бит (2 байт) до 8 бит (1 байт).
    
    ### **Явные и неявные преобразования**
    
    В случае с расширяющими преобразованиями компилятор за нас выполнял все преобразования данных, то есть преобразования были неявными (**implicit conversion**). Такие преобразования не вызывают каких-то затруднений. Тем не менее стоит сказать пару слов об общей механике подобных преобразований.
    
    Если производится преобразование от безнакового типа меньшей разрядности к безнаковому типу большой разрядности, то добавляются дополнительные биты, которые имеют значени 0. Это называется **дополнение нулями** или zero extension.
    
    ```csharp
    byte a = 4;             // 0000100
    ushort b = a;   // 000000000000100
    ```
    
    Если производится преобразование к знаковому типу, то битовое представление дополняется нулями, если число положительное, и единицами, если число отрицательное. Последний разряд числа содержит знаковый бит - 0 для положительных и 1 для отрицательных чисел. При расширении в добавленные разряды компируется знаковый бит.
    
    Рассмотрим преобразование положительного числа:
    
    ```csharp
    sbyte a = 4;            // 0000100
    short b = a;    // 000000000000100
    
    sbyte a = -4;           // 1111100
    short b = a;    // 111111111111100
    ```
    
    ### **Явные преобразования**
    
    При явных преобразованиях (**explicit conversion**) мы сами должны применить операцию преобразования (операция `()`). Суть операции преобразования типов состоит в том, что перед значением указывается в скобках тип, к которому надо привести данное значение:
    
    ```csharp
    int a = 4;
    int b = 6;
    byte c = (byte)(a+b);
    ```
    
    Расширяющие преобразования от типа с меньшей разрядностью к типу с большей разрядностью компилятор проводит неявно. Это могут быть следующие цепочки преобразований:
    
    **byte** -> **short** -> **int** -> **long** -> **decimal**
    
    **int** -> **double**
    
    **short** -> **float** -> **double**
    
    **char** -> **int**
    
    ![Untitled](%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%20%D0%BF%D0%BE%20C#%20732a50f952ff420e83a1c6da8b0a1665/Untitled.png)
    
    Также следует отметить, что несмотря на то, что и double, и decimal могут хранить дробные данные, а decimal имеет большую разрядность, чем double, но все равно значение double нужно явно приводить к типу decimal:
    
    ```csharp
    double a = 4.0;
    decimal b = (decimal)a;
    ```
    
    ### **Потеря данных и ключевое слово checked**
    
    ```csharp
    int a = 33;
    int b = 600;
    byte c = (byte)(a+b);
    Console.WriteLine(c);   // 121
    ```
    
    Результатом будет число 121, так число 633 не попадает в допустимый диапазон для типа byte, и старшие биты будут усекаться. В итоге получится число 121. Поэтому при преобразованиях надо это учитывать. И мы в данном случае можем либо взять такие числа a и b, которые в сумме дадут число не больше 255, либо мы можем выбрать вместо byte другой тип данных, например, int.
    
- Условные выражения
    
    ### Операции сравнения
    
    ```csharp
    1.==
    
    Сравнивает два операнда на равенство. 
    Если они равны, то операция возвращает true, если не равны, 
    то возвращается false:
    
    int a = 10;
    int b = 4;
    bool c = a == b; // false
    
    ------------------------------
    2.!=
    
    Сравнивает два операнда и возвращает true, 
    если операнды не равны, и false, если они равны.
    
    int a = 10;
    int b = 4;
    bool c = a != b;    // true
    bool d = a!=10;     // false
    ------------------------------
    3.<
    
    Операция "меньше чем". Возвращает true, если первый операнд 
    меньше второго, и false, если первый операнд больше второго:
    
    int a = 10;
    int b = 4;
    bool c = a < b; // false
    ------------------------------
    >
    
    Операция "больше чем". Сравнивает два операнда и возвращает
    true, если первый операнд больше второго, иначе возвращает
    false:
    int a = 10;
    int b = 4;
    bool c = a > b;     // true
    bool d = a > 25;    // false
    ------------------------------
    <=
    
    Операция "меньше или равно".
    
    >=
    
    Операция "больше или равно".
    
    int a = 10;
    int b = 4;
    bool c = a >= b;     // true
    bool d = a >= 25;    // false
    
    int a = 10;
    int b = 4;
    bool c = a <= b;     // false
    bool d = a <= 25;    // true
    ```
    
    ### **Логические операции**
    
    - **|**
        
        Операция логического сложения или логическое ИЛИ. Возвращает true, если хотя бы один из операндов возвращает true.
        
        ```csharp
        bool x1 = (5 > 6) | (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
        bool x2 = (5 > 6) | (4 > 6); // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false
        ```
        
    - **&**
        
        Операция логического умножения или логическое И. Возвращает true, если оба операнда одновременно равны true.
        
        ```csharp
        bool x1 = (5 > 6) & (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается false
        bool x2 = (5 < 6) & (4 < 6); // 5 < 6 - true, 4 < 6 - true, поэтому возвращается true
        ```
        
    - **||**
        
        Операция логического сложения. Возвращает true, если хотя бы один из операндов возвращает true.
        
        ```csharp
        bool x1 = (5 > 6) || (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
        bool x2 = (5 > 6) || (4 > 6); // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false
        ```
        
    - **&&**
        
        Операция логического умножения. Возвращает true, если оба операнда одновременно равны true.
        
        ```csharp
        bool x1 = (5 > 6) && (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается false
        bool x2 = (5 < 6) && (4 < 6); // 5 < 6 - true, 4 < 6 - true, поэтому возвращается true
        ```
        
    - **!**
        
        Операция логического отрицания. Производится над одним операндом и возвращает true, если операнд равен false. Если операнд равен true, то операция возвращает false:
        
        ```csharp
        bool a = true;
        bool b = !a;    // false
        ```
        
    - **^**
        
        Операция исключающего ИЛИ. Возвращает true, если либо первый, либо второй операнд (но не одновременно) равны true, иначе возвращает false
        
        ```csharp
        bool x5 = (5 > 6) ^ (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true
        bool x6 = (50 > 6) ^ (4 / 2 < 3); // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается false
        ```
        
    
    Здесь у нас две пары операций `|` и `||` (а также `&` и `&&`) выполняют похожие действия, однако же они не равнозначны.
    
    В выражении `z=x|y;` будут вычисляться оба значения - x и y.
    
    В выражении же `z=x||y;` сначала будет вычисляться значение x, и если оно равно `true`, то вычисление значения y уже смысла не имеет, так как у нас в любом случае уже z будет равно `true`. Значение y будет вычисляться только в том случае, если x равно `false`
    
    То же самое касается пары операций `&/&&`. В выражении `z=x&y;` будут вычисляться оба значения - x и y.
    
    В выражении же `z=x&&y;` сначала будет вычисляться значение x, и если оно равно `false`, то вычисление значения y уже смысла не имеет, так как у нас в любом случае уже z будет равно `false`. Значение y будет вычисляться только в том случае, если x равно `true`
    
    Поэтому операции `||` и `&&` более удобны в вычислениях, так как позволяют сократить время на вычисление значения выражения, и тем самым повышают производительность. А операции `|` и `&` больше подходят для выполнения поразрядных операций над числами.
    
- If/Else
    
    Конструкция if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код.
    
    ```csharp
    if(условие)
    {
        выполняемые инструкции
    }
    ```
    
    После ключевого слова `if` ставится условие. Условие должно представлять значение типа **bool**
    
    ### Выражение else
    
    Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок `else`:
    
    ```csharp
    int num1 = 8;
    int num2 = 6;
    if(num1 > num2)
    {
        Console.WriteLine($"Число {num1} больше числа {num2}");
    }
    else
    {
        Console.WriteLine($"Число {num1} меньше числа {num2}");
    }
    -------------------------------------
    Блок else выполняется, если условие после if ложно, то есть 
    равно false. Если блок else содержит толко одну инструкцию, 
    то оять же мы можем его сократить, убрав фигурные скобки:
    
    int num1 = 8;
    int num2 = 6;
    if(num1 > num2)
        Console.WriteLine($"Число {num1} больше числа {num2}");
    else
        Console.WriteLine($"Число {num1} меньше числа {num2}");
    ```
    
    ### else if
    
    Но в примере выше при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. Используя конструкцию `else if`, мы можем обрабатывать дополнительные условия:
    
    ```csharp
    int num1 = 8;
    int num2 = 6;
    if(num1 > num2)
    {
        Console.WriteLine($"Число {num1} больше числа {num2}");
    }
    else if (num1 < num2)
    {
        Console.WriteLine($"Число {num1} меньше числа {num2}");
    }
    else
    {
        Console.WriteLine("Число num1 равно числу num2");
    }
    ```
    
    ### **Тернарная операция**
    
    Тернарную операция также позволяет проверить некоторое условие и в зависимости от его истинности выполнить некоторые действия. Она имеет следующий синтаксис:
    
    ```csharp
    [первый операнд - условие] ? [второй операнд] : [третий операнд]
    ```
    
    десь сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно `true`, то возвращается второй операнд; если условие равно `false`, то третий. Например:
    
    ```csharp
    int x=3;
    int y=2;
     
    int z = x < y ? (x+y) : (x-y);
    Console.WriteLine(z);   // 1
    ```
    

## Старенькое

- Немного **Visual Studio и** разбор стартового шаблона
    
    ### Создание нового проекта
    
    1. Создание проекта
    2. Выбираем консольное приложение
    3. Выбираем путь и название
    
    *//Для одного решения можно создать несколько проектов*
    
    ```csharp
    using System;
    
    namespace CSharpCOURSE// Note: actual namespace depends on the project name.
    {
        internal class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine("Hello World!"); - вывод в консоль "Hello World!"
            }
        }
    }
    
    using System - используем пространство имён System и его типы
    //Если убрать using System ,то будет ошибка связанная с Console.WriteLine,т.к.
    //тип Console из прост-ва имён System,но если написать System.Console.WriteLine("///"),
    //то будет всё норм
    
    namespace CSharpCOURSE - прост-во имён CSharpCOURSE
    
    class Program - класс
    
    static void Main(string[] args) - главная функция,с которого запускается приложение
    
    //C# регистро-зависимый ,то есть есть разница между большими буквами и маленьками
    //Отладка это процесс выявление ошибок
    ```
    
    ### Сборка и публикация проекта
    
    1. Заходим и выбираем на верхней панеле **build**
    2. Выбираем **build project** +_
    3. На **Solution Explorer**  правой кнопкой нажимаем на проект и выбираем затем **publish**
    4. Затем настраиваем ,что да как и публикуем ⇒ получаем наш экзешник
    
- Переменные
    
    **Переменная** - это контейнер разного типа ,который в себе что-то хранит
    
    **Объявление переменной** - 
    
    1. тип данных переменной + название = значение;
    
    ```csharp
    						int x = -1;
                int y; - можно просто объявить переменную без значения,            
    						y = 2;          а лишь затем указать тип
    
                uint z = 1;
                float f = 1.1f; - f обязательно
                double d = 2.3;
    
                short s = -1;
                int g = 0; === int g1 = new int(); - одно и тоже
    						decimal money = 3.0m; - m обязательно
                char charc = 'a';
                string str = "sasas";
                bool bol = true;
                object obj1 = 1; - любые знач-ия ,но этого лучше не делать
    ```
    
    1. var + название = значение
    
    ```csharp
    var a = 1;
    var b = 1.1f; - если f не написать ,то будет тип double
    
    //Тут тип автоматически определяется по значению прем-ой
    
    //По умолчанию у всех целочис-ых зна-ие 0,у чисел с плав-ей точкой 0.0
    
    //Если используем var,то значение обязательно надо присвоить
    ```
    
    Для обычного использования стоит лучше создавать переменную с явным типом данных,а **var** ,когда название типа очень длинное и т.д. ⇒ используем **var** для укорачивания текста
    
    //Если мы хотим дать наз-ие перем-ой зарезервируемого типа и т.д. надо -
    
    ***char @char = ‘d’;***
    
- Литералы
    
    **Литералы** - это значения ,которые явно прописаны(числа,символы,строки и т.д.)
    
    ```csharp
    Литералы могут в себе хранить как значения в нормальном видк(1,1.1,'d',"str",false),так
    и в бинарном виде(двоичном)
    
    0b - писать обязательно
    int x = 0b11; - 3
    int y = 0b1101; - 13
    int k = 0b10001001; - 137
    int m = 0b100_1001; - 73
    
    Также можно записать в шестнадцатиричной системе
    
    0x - писать обязательно
    x = 0x1f;
    y = 0xff0d;
    k = 0x1fab30ef;
    m = 0x1fab_30ef;
    
    Console.WriteLine(4.5e2); = 4.5 * 10 во второй степени
    Console.WriteLine(3.1e-1); = 3.1 * 10 в минус первой степени
    
    			         Тоже имеет место быть 
    						Console.WriteLine('\x78');
                Console.WriteLine('\x5A'); - хз
    
                Console.WriteLine('\u0420'); - Unicode
                Console.WriteLine('\u0421');
    ```
    
- Область видимости переменных
    
    ```csharp
    static void Main(string[] args)
            {
    
                var a = 1;
                1.{
                    var b = 2;
                    2.{
                        var c = 3;
                        Console.WriteLine(a); - тут всё ок
                        Console.WriteLine(b);
                        Console.WriteLine(c);
    
                    }
    
                    Console.WriteLine(a);
                    Console.WriteLine(b); - но тут уже не выведется **c**
                    Console.WriteLine(c);   т.к. в этой области 1(скоупе) мы не видим её
                }
                   Console.WriteLine(a);
                   Console.WriteLine(b); - а тут уже не выведется b и **c,**
    							 Console.WriteLine(c);   по аналогичным причинам(т.к. тут мы вне каких скоупов)
    
            }
    
    {} - скоуп (некое пространство)
    Подытожим - 
    Внутренние скоупы видет переменные и т.д. из внешних скоупов,а внешние из внутрен-
    них нет(1 - внешний скоуп,2 - внутренний)
    ```
    
- Переполнение**(OverFlow)**
    
    **Переполнение** - когда мы переходим максимальное значение ,который может содержать данный тип
    
    ```csharp
    uint x = uint.MaxValue;
    Console.WriteLine(x); - выведет макс знач
    x += 1;
    Console.WriteLine(x); - выведет 0 ,из-за того ,что вышли за максимум ,и значение
    вместо того ,чтобы увеличиться возращается к минимальному и уже к нему прибаляет и т.д.
    x -= 1;
    Console.WriteLine(x); - снова выведет макс знач
    
    Чтобы компилятор не запустил программу с переполнением и просто выделил ошибку -
    пишем  **checked - 
    {
                checked {             
    	            uint x = uint.MaxValue;
    
    	            x += 1;
    
    	            Console.WriteLine(x); - переполнение - ошибка
    
    	            x -= 1;
    
    	            Console.WriteLine(x);}
    
            }
    
    Но код ,который находится в блоке checked ,работает медленнее.Из-за этого 
    лучше следить за переполнением в коде ,но если нужны очень точные рассёты и точность
    ,то лучше использовать его
    
    Также можно в настройках VS поставить checked на весь проект - 
    Solution Explorer - прав. кн. мыши - Properties - Build - CheckForArithmetic OverFlow**
    ```
    
- Алгебраические операции
    
    ```csharp
    1.Сложение(инкримент) - постфиксная форма
    int x = 1;
    x++; - обычное сложение
    x += 1.....99999;
    
    2.Сложение(инкримент) - инфиксная форма
    int x = 1;
    ++x;
    
    3.Вычитание(дикримент)
    int x = 1;
    x--; - постфиксная форма  
    --x; - инфиксная форма
    x -= 1.....99999;
    
    4.Умножение и деление
    x *= 3; - умножить на 3
    x /= 3; - разделить на 3
    
    5.Остаток от деления
    x = 4 % 2;
    y = 5 % 2;
    
    Console.WriteLine(x); - 0
    Console.WriteLine(y); - 1
    
    6.Операторы сравнения
    x > y; - строгое сравнение
    x >= y; - нестрогое сравнение
    x < y;
    x <= y;
    x == y; - сравнение
    x != y; - не равно 
    Разница между постфиксной формой и префиксной - 
    int x = 1;
    
    int j = x++; - тут у нас постфиксная форма,поэтому мы сначала присваиваем в **j** уже
    имеющееся значение **x** ,а затем прибавляем единицу к **x**
    Console.WriteLine(j); - 1
    Console.WriteLine(x); - 2
    
    int y = ++x; - тут у нас префиксная форма,поэтому мы сначала прибавляем единицу к **x** 
    ,а затем уже присваиваем значение **x** к **j**
    Console.WriteLine(y); - 3
    Console.WriteLine(x); - 3
    
    Аналогично в дикрементами
    ```
    
- Экземплярные и статические методы
    
    ```csharp
    string str = "abrakadabra"; - мы создали экземпляр строки(экземпляр типа string)
    т.к. это равно этой записи
    string str = new string("abrakadabra");
    
    						string str = "abrakadabra"; - создали экземпляр типа string
                bool containsName = str.Contains('a'); - использовали экзем-ые методы этипа string
                bool containsValue = str.Contains('b');  на экземпляре str
                Console.WriteLine(containsName);
                Console.WriteLine(containsValue);
    
                string abc = string.Concat("a", "b", "c"); - мы еще не создав экземпляр,можем использовать
                Console.WriteLine(abc); - статич-ий метод string Concat 
    
                Console.WriteLine(int.MinValue); - тут аналогично(всё без экземпляров)
    
    Разница между экземплярными методами и статическими в том,что экземплярные методы 
    могут быть использоваными ,только экземплярами данного типа,а для использования
    статических методов не нужно создавать экземпляры какого-либо типа,их можно использовать всегда
    
    ```
    
- Базовый API для работы со строками
    
    **API** - это т как мы работаем с типом,его методами,свойствами
    
    ## Методы строк и свойства
    
    **string.Concat** - объединяет строки**(статический)**
    
    ```csharp
    string abc = string.Concat("a", "b", "c");
    ```
    
    **x.ToString** - перевод какого-либо типа данных в строку(статический)
    
    ```csharp
    string toString = x.ToString();
    Console.WriteLine(toString);
    ```
    
    **str.Contains** - проверяет строку на наличии буквы или строки(экземплярный)
    
    возвращает true/false
    
    ```csharp
    						string str = "abrakadabra";
                bool containsName = str.Contains('a');
                bool containsValue = str.Contains('b');
                Console.WriteLine(containsName);
                Console.WriteLine(containsValue);
    ```
    
    **name.Substring** - обрезает строку по индексамя(экземплярный)
    
    ```csharp
    string name = "abrakadabra";
    string str = name.Substring(5); - включительно с 5-го тндекса и до конца 
    string str1 = name.Substring(0, 3); - не включительно
    Console.WriteLine(str); - adabra
    onsole.WriteLine(str1); - abr
    ```
    
    **name.IndexOf** - возвращает индекс первой указанной буквы(экземплярный)
    
    **name.LastIndexOf** - возвращает последний индекс указанной буквы(экземплярный)
    
    ```csharp
    string name = "abrakadabra";
    int indexOfA = name.IndexOf('a');
    Console.WriteLine(indexOfA); - 0
    
    int indexOfA = name.IndexOf('a',1); - 1 это с какого индекса будет искать 
    Console.WriteLine(indexOfA); - 3
    
    int lastIndexOfR = name.LastIndexOf('r');
    Console.WriteLine(lastIndexOfR) - 9
    ```
    
    **name.StartsWith** - возвращает true/false ,если строка начинается с какой-то строки или буквы
    
    **name.EndsWith** - возвращает true/false ,если строка заканчивается с какой-то строки или буквы
    
    ```csharp
    						string name = "abrakadabra";
                bool endsWithAbra = name.EndsWith("abra"); - true
                Console.WriteLine(endsWithAbra);
    
                bool startsWithAbra = name.StartsWith("abra");- true
                Console.WriteLine(startsWithAbra);
    ```
    
    **name.Length** - возвращает кол-во букв в строк
    
    ```csharp
    string name = "abrakadabra";
    Console.WriteLine(name.Length);
    
    ```
    
    **string.IsNullOrEmpty** - проверяет строку на пустоту
    
    ```csharp
    						string empty = "";
                string whiteSpaced = " ";
                string notEmpty = " b";
                string nullString = null;
    
                bool isNullOrEmpty = string.IsNullOrEmpty(empty);
                Console.WriteLine(isNullOrEmpty);
    
                bool isNullOrEmpty1 = string.IsNullOrEmpty(whiteSpaced);
                Console.WriteLine(isNullOrEmpty1);
    
                bool isNullOrEmpty2 = string.IsNullOrEmpty(notEmpty);
                Console.WriteLine(isNullOrEmpty2);
    
                bool isNullOrEmpty3 = string.IsNullOrEmpty(nullString);
                Console.WriteLine(isNullOrEmpty3);
    ```
    
    **string.IsNullOrEmpty()** - возвращает true/false  и проверяет на пустоту строку**(статический)**
    
    ```csharp
    string empty = "";
     bool isNullOrEmpty = string.IsNullOrEmpty(empty);
                Console.WriteLine(isNullOrEmpty);-True
    ```
    
    **string.IsNullOrWhiteSpace()** - возвращает true/false  и проверяет на пустоту строку +даже если есть пробелы**(статический)** улучшенный **string.IsNullOrEmpty**
    
    ```csharp
    						string empty = "";
                string whiteSpaced = " ";
                string notEmpty = " b";
                string nullString = null;
    
    						bool isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(empty);
                Console.WriteLine(isNullOrWhiteSpaced);
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(whiteSpaced);
                Console.WriteLine(isNullOrWhiteSpaced);
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(notEmpty);
                Console.WriteLine(isNullOrWhiteSpaced);
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(nullString);
                Console.WriteLine(isNullOrWhiteSpaced);
    ```
    
    **string.Empty** - **свойство** ,которое в строку записывает пустоту
    
    ```csharp
    string str = string.Empty; == string str1 = "";
    ```
    
    **string.Join** - объединяет строки**(статический)**,только перед тем ,как объединить мы указываем ,как они будут разделяться
    
    ```csharp
    string join = string.Join(" ", "My", "name","is","Jone");
    - будут разделяться пробелом
    ```
    
    **join.Insert()** - добавляет новые слова в строку**(экземплярный)**.Нужно указать с какого тндекса добавить и ,что добавить
    
    ```csharp
    string join = string.Join(" ", "My", "name","is","Jone");
    join = join.Insert(0, "Hello "); - с 0-го индекса добавляем Hello
    Console.WriteLine(join); - Hello My name is Jone
    ```
    
    **join.Remove()** - удаление строки или подстроки**(экземплярный)**
    
    ```csharp
    join = join.Remove(0); - если указать один аргумент ,то удалится всё ,что 
    идет после этого индекса(в данном случае вся строка)
    
    join = join.Remove(0,4); - если указать два аргумента ,то удалится ,то 
    удалится указанное кол-во букв и т.д. идущих после этого индекса
    (не включительно)
    ```
    
    **join.Replace()** - заменяет указанные буквы или строки на другие**(экземплярный)**
    
    ```csharp
    string join = string.Join(" ", "My", "name","is","Jone");
    string replaced = join.Replace('n', 'z'); - обязательно ординарные ковычки
    Console.WriteLine(replaced); - My zame is Joze
    
    string replaced = join.Replace("abra","kadaba");
    ```
    
    **data.Split()** - обрабатывает строку ,тем самым её ,разделяя,и,убирая,разделители(;, , / .  и т.д.)возвращает массив данных
    
    **(экземплярный)** 
    
    ```csharp
    string data = "12;13;165;";
    string[] spliData = data.Split(';'); - указываем какой разделитель мы убираем
    string first = spliData[0]; - и разделяя получаем 3 строки(12,13,165)
    
    ```
    
    **join.ToCharArray()** - разбивает строку на массив чаров**(экземплярный)** 
    
    ```csharp
    string join = string.Join(" ", "My", "name","is","Jone");
    char[] chars = join.ToCharArray();
    Console.WriteLine(chars[0]); - M
    
    Но также можно обращаться и на прямую к чарам из строки 
    Console.WriteLine(join[4]);
    ```
    
    **join.ToLower() и join.ToUpper()** - первый метод преобразует все чары в верхний регистр ,второй наоборот в нижний**(экземплярные)**
    
    ```csharp
    						string lower = join.ToLower();
                Console.WriteLine(lower); - o my name is jone
    
                string upper = join.ToUpper();
                Console.WriteLine(upper); - O MY NAME IS JONE
    ```
    
    **str.Trim()** - обрезает лишние пробелы в строке**(экземплярный)**
    
    ```csharp
    string str = " My name is John";
    str = str.Trim();
    Console.WriteLine(str); -My name is John
    ```
    
- Пустота строк
    
    **null** - это литерал ,указывающий на отсутствие экземпляра(пустота абсолютная и отсутствие памяти)
    
    ```csharp
    						string nullString = null;
    						string empty = "";
                string whiteSpaced = " ";
                string notEmpty = " b";
                string nullString = null;
    
                bool isNullOrEmpty = string.IsNullOrEmpty(empty);
                Console.WriteLine(isNullOrEmpty);-True
    
                bool isNullOrEmpty1 = string.IsNullOrEmpty(whiteSpaced);
                Console.WriteLine(isNullOrEmpty1); - False
    
                bool isNullOrEmpty2 = string.IsNullOrEmpty(notEmpty);
                Console.WriteLine(isNullOrEmpty2);-False
    
                bool isNullOrEmpty3 = string.IsNullOrEmpty(nullString);
                Console.WriteLine(isNullOrEmpty3); - True
    
    						bool isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(empty);
                Console.WriteLine(isNullOrWhiteSpaced); - True
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(whiteSpaced);
                Console.WriteLine(isNullOrWhiteSpaced); - True
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(notEmpty);
                Console.WriteLine(isNullOrWhiteSpaced); - False
    
                isNullOrWhiteSpaced = string.IsNullOrWhiteSpace(nullString);
                Console.WriteLine(isNullOrWhiteSpaced); - True
    ```
    
    В **C# для**  **string.IsNullOrEmpty** пустой строкой считается строка ,которая хранит в себе ничего(””) или **null**
    
    А вот  уже для **string.IsNullOrWhiteSpace** пустой строкой считается строка ,которая хранит в себе ничего(””) или **null**
    
- Изменение строк
    
    Методы инстанции не изменяют **инстанцию(в данном случае строка)**,а возвращают новое значение
    
    ```csharp
    string join = string.Join(" ", "My", "name","is","Jone");
    
    join = join.Insert(0, "Hello ");
    Console.WriteLine(join); - Hello My name is Jone
    
    но ,а если мы так запишем -
    
    join.Insert(0, "Hello ");
    Console.WriteLine(join); - My name is Jone
    
    крч нужно обязательно присваивать новые значения,т.к иначе изменения 
    не вступят в силу
    
    string conCats = "my" + "name"; - аналогично ConCut
    ```
    
- StringBuilder
    
    ```csharp
    StringBuilder sb = new StringBuilder();
    //чтобы его использовать надо подключить прост-во имён System.Text
    
    StringBuilder - это собиратель строк
    sb.Append() - это метод StringBuilder добавляет в наш собиратель строк строку
    sb.AppendLine() - это метод StringBuilder добавляет в наш собиратель строк строку,только уже после этой
    строки ,все остальные строки будут выводиться ниже(тог есть отступ)
    
    sb.Append("My ");
    sb.Append("name");
    sb.Append(" John");
    sb.AppendLine("!");
    sb.AppendLine("Hello"); 
    string str = sb.ToString(); - в str записываем готовую строку из StringBuilder
    Console.WriteLine(str);
    -
    -My name John!
    Hello
    
    //Главное отличие от обычных строк ,заключается в том ,что StringBuilder ,модифици-
    //рует строку и не нужно ,каждое изменение присваивать ему,а просто вызвать метод
    
    StringBuilder лучше использовать ,когда нужно сложить очень много строк,т.к. он
    обеспечивает наибольшую производительность по отношению к ConCut,Join и конкетынации
    ```
    
- Форматирование строк
    
    ```csharp
    string name = "John";
    int age = 40;
    string str1 = string.Format("My name is {0} and i'm {1}", name,age);
    **string.Format()** - (статический) метод ,собирающий строку из нескольких 
    частей.
    
    Для этого нужно поставить фиг-ые(плейсхолдеры) скобки и от 0 вставлять в них 
    цифры,затем указываем переменные откуда мы берем значения.
    (куда мы вставили 0 ,то туда возьмётся значение первой индущей 
    перем-ой,аналогичное с остальными цифрами и переменным)
    
    string str2 = $"My name is {name} anm i'm {age}"; - упрощенный
    string.Format(),тут уже сразу в плейсхолдеры записываем перем-ые
     - Это интерпалирование строк
    
    Эскейп последовательности - 
    
    **\n** - перенос на новую строку
    
    string str3 = "My name \n John";
    Console.WriteLine(str3); -
    My name
     John
    
    **\t** - табуляция
    string str4 = "i'm \t John";
    str3 = $"My name is {Environment.NewLine} John";
    **Environment.NewLine** - аналогично \t
    Разница в том ,что в разных ОП перенос на новую строку(например) может
    осуществиться разными путями (где-то \r\n ,а где-то \n).
    
    Environment.NewLine - это кросс-платформенное решение,то есть оно
    будет переносить строку на всех ОП
    
    **\**" cshsbb **\**" - экранирование ""
    str4 = "My name is John \"Programmer\""; 
    - My name is John "Programmer"
    
    Чтобы экранировать **\** ,нужно поставить ещё один **\**
    str3 = "C:\\tmp\\test_file.txt"; - C:\tmp\test_file.txt
    
    @ - не нужно ставить \ для их экранизации.
    Стоит использовать ,если используем много слешей
    string str6 = @"c:\tmp\test_file.txt";
    
    Специализированное форматирование
    
    d - знак форматирования(добавления нулей)
    //Нельзя использовать для double
    int answer = 2;
    string result = string.Format("{0:d}", answer);
    string result2 = string.Format("{0:d4}", answer);
    Console.WriteLine(result); - 2
    Console.WriteLine(result2); - 0002
    {0:d4} - если числе не четырёх значное ,то при выводе выведется ,то кол-во 0 ,которое
    не хватает выводимому числу до четырёхзначного числа,а если это четыр-ое число ,то ничего не будет
    (это зависит от 0:d какая цифра будет тут стоять(5,6,7,8))
    
    f - знак форматирования десятичные дроби и т.д.(округление)
    result = string.Format("{0:f}", answer);
    result2 = string.Format("{0:f4}", answer);
    Console.WriteLine(result); - 2,00
    Console.WriteLine(result2); - 2,0000
    аналогично с {0:d4} указывается кол-во нулей после запятой
    
    double answer1 = 42.08;
    result = String.Format("{0:f1}",answer1);
    Console.WriteLine(result); - 42.1
    
    C - знак форматирования(валюта) + также округляет
    
    double money = 98.98;
    result = String.Format("{0:C}",money); - 98,98 ₽
    result2 = String.Format("{0:C1}", money); - 99,0 ₽
    
     Также всё это можно записать покороче - 
    
    Console.WriteLine(money.ToString("C2"));
    Console.WriteLine(answer.ToString("d"));
    Console.WriteLine(answer1.ToString("f"));
    
    Указываем перем-ую ,которую хотим отформатировать.Затем ToString(),а в 
    скобки пишем знак форматирования + цифру для округления
    Или с помощью интерполяции строк
    result = $"{money:C2}"; - аналогично : пишем перем-ую ,а затем знак 
    форматирования
    ```
    
- Сравнение строк

- Горячие клавиши
    
    **cw + Tab** = Console.WriteLine(’’);

val nums = List(1,2,3) val p = Person("Martin", "Odersky")
-----------------------
nums.map(i => i * 2) // длинная форма nums.map(_ * 2) // краткая форма nums.filter(i => i > 1) nums.filter(_ > 1)
-----------------------
trait Animal:
	def speak(): Unit
trait HasTail:
	def wagTail(): Unit 
class Dog extends Animal, HasTail: 
	def speak(): Unit = println("Woof") 
	def wagTail(): Unit = println("⎞⎜⎛ ⎞⎜⎛")
