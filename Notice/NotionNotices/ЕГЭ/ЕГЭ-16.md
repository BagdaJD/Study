# ЕГЭ-16

- **Типовое задание(рекурсия)**
    
    ```python
    '''
    20) Алгоритм вычисления функций F(n) и G(n) задан
    следующими соотношениями:
    	(1)	F(1) = G(1) = 1
    		(2) F(n) = 3·F(n–1) + G(n–1) – n + 5, если n > 1
    
    		G(n) = F(n–1) + 3·G(n–1) – 3·n, если n > 1
    Чему равно значение F(14) + G(14)?
    '''
    def F(n):
        if n == 1:#(1)
            return 1
        return 3*F(n-1) + G(n-1) - n + 5 #(2)
    
    def G(n):
        if n == 1:
            return 1
        return F(n-1) + 3*G(n-1) - 3*n
    
    print(F(14) + G(14))#37282721
    '''
    Алгоритм:
    1)Использовать рекурсию(-и-) ,а для её написания используем условие
    '''
    '''
    Доп.инфа
    
    Если по условию ,говорится ,что траектория должна идти через какое-то число 
    ,то пишем так(например 7 от 1  до 87) - 
    *print(F(1,7)*F(7,87))*
    '''
    '''
    Если говорится ,что наша траектория не должна содержать какое-то число,
    то пишем так( например не должна содержать 8 от 1 до 76)
    
    def F(n):
    	if .... or n == 8:
    		....
    
    print(F(1,76))
    '''
    ```
    
- **Типовое задание(через массивы,альтернативынй вариант)**
    
    ```python
    '''
    41) Алгоритм вычисления функций F(n) и G(n) задан следующими соотношениями:
    	    F(n) = G(n) = 1 при n = 1
    	    F(n) = F(n–1) – 2 · G(n–1), при n > 1
    	    G(n) =  F(n–1) + G(n–1) + n, при n > 1
    Чему равна сумма цифр значения функции G(36)?
    '''
    def sumdig(n):
        sm = 0
        while n > 0:
            dig = n % 10
            sm += dig
            n //= 10
        return sm
    
    nn = 36
    F = [0]*(nn+1)
    G = [0]*(nn+1)
    F[1] = G[1] = 1
    
    for n in range(2,nn+1):
        F[n] = F[n-1] - 2 * G[n-1]
        G[n] = F[n-1] + G[n-1] + n
    
    print(sumdig(G[36]))#40
    
    '''
    Алгоритм:
    1)Создаем перем-ую nn - G(36)(то есть нужный номер)
    2)Создаем нужное кол-во массивов(сколько функций ,столько и массивов)
    F = [0]*(nn+1) - на один больше ,т.к счёт в массиве начинается с 0 
    G = [0]*(nn+1)
    3)Пишем код по условию
    F[1] = G[1] = 1
    4)Потом перебираем n от 2(т.к F[1] = G[1] = 1) до nn+1 и вставляем в цикл условие,
    ток меняем круглые скобки на квадратные
    for n in range(2,nn+1):
        F[n] = F[n-1] - 2 * G[n-1]
        G[n] = F[n-1] + G[n-1] + n
    '''
    ```
    
- **Задание ,где F(n) - определено**
    
    ```python
    '''
    67)	(Е. Джобс) Алгоритм вычисления функции F(n), где
    n – натуральное число, задан следующими соотношениями:
    
    F(n) = n + 1 при n < 3,
    F(n) = n + 2*F(n + 2), когда n ≥ 3 и четно,
    F(n) = F(n – 2) + n – 2, когда n ≥ 3 и нечетно.
    
    Сколько существует чисел n, для которых значение F(n)
    определено и будет трехзначным?
    '''
    
    def F(n):
        if n < 3:
            return n + 1
        if n % 2 == 0:
            return n + 2*F(n + 2)
        return F(n - 2) + n - 2
    '''
    cnt = 0
    for n in range(1, 1000, 2):
        res = F(n)
        if 99 < res < 1000:
            cnt += 1
    
    print(cnt)
    '''
    cnt = 0
    for n in range(1, 1000):
        try:
            res = F(n)
            if 99 < res < 1000:
                cnt += 1
        except:
            pass
    print(cnt)
    '''
    Алгоритм:
    1)Начало всё тоже самое(пишем функцию под задачу)
    2)Затем делаем цикл ,где перебираем n
    //Используем кон-ию try/except ,чтобы наш код работал ,несмотря на ошибки
    
    '''
    ```