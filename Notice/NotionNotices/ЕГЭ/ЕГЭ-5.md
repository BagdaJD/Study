# ЕГЭ-5

- ***Обычное задание+бит четности***
    
    ```python
    def n2r(n):
        n2 = bin(n)[2:]
        if n2.count('1') % 2 == 0:
            n2 = n2 + '11'
        else:
            n2 = n2 + '01'
        r = int(n2, 2)
        return r
    
    t = []
    for n in range(1, 100):
        r = n2r(n)
        if r > 31:
            t += [r]
    
    print(min(t))
    ***#Бит четности* добавляет 1 ,если кол-во 
    #единиц нечетно,если четно то 0**
    ```
    
- ***Неплохая задача***
    
    ```python
    '''
    279)	На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
    1. Вычисляется сумма S1 всех нечётных цифр десятичной записи
    числа N. Если нечётных цифр нет, сумма S1 считается равной 0.
    
    2. Вычисляется сумма S2 всех цифр десятичной записи числа N,
    стоящих на позициях с чётными номерами. Позиции нумеруются слева
    направо, начиная с 1. Для однозначных чисел сумма S2 считается
    равной 0.
    
    3. Вычисляется результат R как модуль разности S1 и S2.
    Пример: Дано число N = 1234. Сумма нечётных цифр S1 = 1 + 3 = 4.
    Сумма цифр в позициях с чётными номерами S2 = 2 + 4 = 6.
    Результат работы алгоритма R = 6 – 4 = 2.
    
    Укажите наименьшее число, в результате
    обработки которого по данному алгоритму получится число 29.
    
    '''
    def sumN(n):
        s = 0
        while n > 0:
            dig = n % 10
            if dig % 2 != 0:
                s += dig
            n //= 10
        return s
    
    def sumR(n):
        s = str(n)
        s = s[::-1]
        sm = 0
        for i in range(0, len(s), 2):
            sm += int(s[i])
        return sm
    
    def n2r(n):
        s1 = sumN(n)
        s2 = sumR(n)
        r = abs(s1 - s2)
        return r
    
    a = []
    for n in range(500000,7000001):
        r = n2r(n)
        if r == 29:
            a.append(n)
    
    print(min(a))#6080818
    ```
    
- ***Доп.инфа***
    
    ```python
    Если наше число при преобразованиях ,каординально может измениться исходя из
    условий то лучше заводить список
    -------------------------------------
    Доп способ
    def n2p(n, p):
        s = ''
        while n > 0:
            dig = n % p
            sdig = sorted('0123456789qwertyuiopasdfghjklzxcvbnm')[dig]
            s = sdig + s
            n = n // p
        return s
    ```